# -*- coding: utf-8 -*-

import os
import logging
import random
import io
from datetime import datetime
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ChatMember,
    ChatMemberUpdated,
)
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    ChatMemberHandler,
    ConversationHandler,
)
from telegram.constants import ParseMode
import psycopg2
from PIL import Image, ImageDraw, ImageFont
import arabic_reshaper
from bidi.algorithm import get_display
import time
import asyncio

# --- پیکربندی اصلی ---
OWNER_IDS = [7662192190, 6041119040] # آیدی‌های عددی ادمین‌های اصلی ربات
SUPPORT_USERNAME = "OLDKASEB" # یوزرنیم پشتیبانی بدون @
FORCED_JOIN_CHANNEL = "@RHINOSOUL_TM" # کانال عضویت اجباری با @
GROUP_INSTALL_LIMIT = 50 # حداکثر تعداد گروه‌هایی که ربات می‌تواند در آن‌ها نصب شود
INITIAL_LIVES = 10 # تعداد جان اولیه در بازی حدس کلمه

# --- تعریف حالت‌های مکالمه ---
# برای بازی قارچ
ASKING_GOD_USERNAME, CONFIRMING_GOD = range(2)
# برای بازی حدس عدد
SELECTING_RANGE, GUESSING = range(2, 4)
# برای اعتراف سفارشی
ENTERING_ETERAF_TEXT = range(4, 5)

# --- لیست کلمات و جملات (بدون تغییر) ---
WORD_LIST = [
    "اسب", "گاو", "گوسفند", "بز", "مرغ", "خروس", "جوجه", "اردک", "غاز", "بوقلمون", "شتر", "الاغ", "قاطر", "سگ", "گربه",
    "موش", "خرگوش", "همستر", "خوکچه", "سنجاب", "لاکپشت", "مار", "تمساح", "سوسمار", "مارمولک", "قورباغه", "وزغ",
    "ماهی", "کوسه", "نهنگ", "دلفین", "هشتپا", "عروس", "دریایی", "ستاره", "خرچنگ", "میگو", "صدف", "حلزون",
    "شیر", "ببر", "پلنگ", "یوزپلنگ", "گرگ", "روباه", "شغال", "کفتار", "خرس", "گراز", "گوزن", "آهو", "جبیر", "گورخر",
    "فیل", "کرگدن", "اسب", "آبی", "زرافه", "کانگورو", "کوالا", "پاندا", "میمون", "گوریل", "شامپانزه", "اورانگوتان",
    "خفاش", "جغد", "عقاب", "شاهین", "باز", "کرکس", "لاشخور", "کلاغ", "زاغ", "گنجشک", "کبوتر", "قمری", "یاکریم",
    "پرستو", "بلبل", "قناری", "سهره", "طوطی", "مرغ", "عشق", "مرغ", "مینا", "دارکوب", "پنگوئن", "شترمرغ", "فلامینگو",
    "پلیکان", "مرغابی", "قو", "لک", "لک", "حواصیل", "درنا", "کبک", "بلدرچین", "قرقاول", "طاووس", "پروانه", "شاپرک",
    "زنبور", "عسل", "زنبور", "وحشی", "مورچه", "موریانه", "پشه", "مگس", "سوسک", "کفشدوزک", "ملخ", "آخوندک", "جیرجیرک",
    "عنکبوت", "رتیل", "عقرب", "هزارپا", "صدپا", "کرم", "خاکی", "پاندا", "راسو", "سمور", "موش", "کور", "جوجه", "تیغی",
    "گورکن", "راکون", "لاما", "آلپاکا", "بوفالو", "گاومیش", "بایسون", "کل", "قوچ", "بزکوهی", "سیاهگوش", "کاراکال",
    "جگوار", "پوما", "بابون", "ماندریل", "لمور", "مارموست", "تامارین", "تنبل", "مورچهخوار", "آرمادیلو", "وامبت",
    "راکن", "نامبت", "تشی", "نوکاردکی", "پلاتیپوس", "اکیدنا", "والابی", "کاسوآری", "امو", "کیوی", "توکان", "ماکائو",
    "کاکاتو", "هورنبیل", "مرغ", "مگسخوار", "آلبرتوس", "مرغ", "دریایی", "پافین", "گیلموت", "کورمورانت", "فک",
    "شیر", "دریایی", "گراز", "دریایی", "والروس", "سمور", "آبی", "بیور", "کپیبارا", "نوتریا", "مارموت", "راسوی",
    "قطبی", "ولورین", "توله", "سگ", "بچه", "گربه", "کره", "اسب", "بره", "بزغاله", "گوساله", "توله", "شیر", "توله", "خرس",
    "ایگوانا", "آفتابپرست", "گکو", "بوا", "پیتون", "آناکوندا", "کبری", "مامبا", "رتل", "افعی", "مارزنگی", "سمندر",
    "تریتون", "آکسولوتل", "پیرانا", "گربهماهی", "سالمون", "قزلآلا", "تون", "شمشیرماهی", "باراکودا", "ارهماهی",
    "سفرهماهی", "اسب", "دریایی", "ژلهماهی", "شقایق", "دریایی", "مرجان", "اسفنج", "دایناسور", "تیرانوزاروس",
    "استگوزاروس", "تریسراتوپس", "برانتوزاروس", "پتروداکتیل", "ماموت", "ببر", "دندان", "شمشیری", "اژدها", "ققنوس",
    "یونیکورن", "پگاسوس", "گریفین", "سنتور", "پری", "دریایی", "سایرن", "ققنوس", "سیمرغ", "عنقا", "هما", "اژدها",
    "هیولا", "دیو", "جن", "پری", "فرشته", "شیطان", "روح", "شبح", "زامبی", "خونآشام", "گرگینه", "مومیایی", "اسکلت",
    "عنقا", "مارماهی", "لابستر", "کالاماری", "اختاپوس", "بادکنکماهی", "پروانهماهی", "فرشتهماهی", "دلقکماهی",
    "جراحماهی", "طوطیماهی", "گاوکوسه", "چکشکوسه", "ببرکوسه", "نهنگ", "قاتل", "اورکا", "نهنگ", "آبی", "نهنگ", "گوژپشت",
    "نهنگ", "سفید", "بلوگا", "ناروال", "خوک", "دریایی", "سگ", "آبی", "گربه", "وحشی", "سروال", "اوسلوت", "وشق",
    "کوگار", "کایوت", "دینگو", "فنک", "روباه", "قطبی", "پولهکت", "ارمینی", "مینک", "گوزن", "شمالی", "موس", "کاریبو",
    "آیآی", "گالگو", "پوتو", "لوریس", "تارسیر", "قورباغه", "درختی", "قورباغه", "سمی", "قورباغه", "پیکانی",
    "قورباغه", "گوجهفرنگی", "مار", "پرنده", "مار", "درختی", "مار", "مرجانی", "لاکپشت", "چرمی", "لاکپشت", "سبز",
    "لاکپشت", "پوزهعقابی", "لاکپشت", "الیگاتور", "کایمن", "کروکودیل", "گاریال", "توآتارا", "اژدهای", "کومودو",
    "بزمجه", "وارانوس", "سوسک", "هرکول", "سوسک", "گوزنی", "سوسک", "کرگدنی", "سوسک", "جواهری", "شبتاب", "کرم",
    "شبتاب", "زنبور", "نجار", "زنبور", "کاغذی", "زنبور", "عنکبوتی", "هیره", "کنه", "شپش", "کک", "ساس", "عقرب", "باد",
    "عقرب", "شلاقی", "عنکبوت", "شلاقی", "عنکبوت", "شکاری", "عنکبوت", "گرگی", "عنکبوت", "پرندهخوار", "گولیاث",
    "بیوه", "سیاه", "عنکبوت", "پشت", "قرمز", "عنکبوت", "گوشهنشین", "قهوهای", "خرخاکی", "میلیپد",
    "زمین", "خورشید", "ماه", "ستاره", "سیاره", "کهکشان", "آسمان", "ابر", "باران", "برف", "تگرگ", "مه", "شبنم", "یخ",
    "باد", "طوفان", "گردباد", "رعد", "برق", "صاعقه", "رنگینکمان", "شفق", "فجر", "غروب", "طلوع", "کسوف", "خسوف",
    "کوه", "قله", "دامنه", "تپه", "دره", "جلگه", "دشت", "بیابان", "کویر", "صخره", "سنگ", "خاک", "گل", "شن", "ماسه",
    "جنگل", "بیشه", "مرتع", "چمنزار", "باتلاق", "تالاب", "مرداب", "رود", "رودخانه", "نهر", "جویبار", "چشمه", "آبشار",
    "دریا", "اقیانوس", "خلیج", "ساحل", "جزیره", "شبهجزیره", "دماغه", "آبراهه", "تنگه", "کانال", "دریاچه", "برکه",
    "موج", "جزر", "مد", "گرداب", "آتشفشان", "گدازه", "دهانه", "خاکستر", "زلزله", "گسل", "سونامی", "سیل", "بهمن",
    "رانش", "زمین", "خشکسالی", "قحطی", "آلودگی", "محیط", "زیست", "اکوسیستم", "جغرافیا", "قاره", "اقلیم", "آب", "هوا",
    "دما", "رطوبت", "فشار", "جو", "اتمسفر", "اقیانوسیه", "آفریقا", "اروپا", "آسیا", "آمریکا", "قطب", "شمال", "جنوب",
    "استوا", "مدار", "نصفالنهار", "طول", "جغرافیایی", "عرض", "کره", "شفق", "قطبی", "کهربا", "الماس", "طلا", "نقره",
    "مس", "آهن", "سرب", "روی", "آلومینیوم", "زغال", "سنگ", "نفت", "گاز", "معدن", "غار", "قندیل", "چاه", "آرتزین",
    "یخچال", "طبیعی", "کوه", "یخی", "تندرا", "تایگا", "ساوانا", "استپ", "فلات", "پرتگاه", "صخره", "مرجانی", "خزه",
    "جلبک", "گیاه", "درخت", "بوته", "گل", "شکوفه", "غنچه", "برگ", "شاخه", "تنه", "ریشه", "ساقه", "میوه", "دانه",
    "سبزه", "علف", "کاکتوس", "پیچک", "نیلوفر", "ارکیده", "رز", "لاله", "نرگس", "بنفشه", "مریم", "یاسمن", "سرو",
    "کاج", "بلوط", "افرا", "بید", "چنار", "صنوبر", "گردو", "بادام", "پسته", "خرما", "نارگیل", "زیتون", "انگور",
    "سیب", "پرتقال", "لیمو", "موز", "انبه", "آناناس", "توتفرنگی", "گیلاس", "آلبالو", "هلو", "شلیل", "زردآلو",
    "آلو", "هندوانه", "خربزه", "طالبی", "خیار", "گوجه", "فرنگی", "پیاز", "سیر", "سیبزمینی", "هویج", "کلم", "کاهو",
    "اسفناج", "قارچ", "لوبیا", "نخود", "عدس", "برنج", "گندم", "جو", "ذرت", "ادویه", "زعفران", "زنجبیل", "دارچین",
    "فلفل", "نمک", "شکر", "عسل", "کهکشان", "راه", "شیری", "آندرومدا", "سحابی", "خوشه", "پروین", "شهابسنگ", "شهاب",
    "دنبالهدار", "سیارک", "منظومه", "شمسی", "جاذبه", "فضا", "زمان", "سیاهچاله", "کوتوله", "سفید", "غول", "سرخ",
    "ابرنواختر", "پالسار", "کوازار", "ماده", "تاریک", "انرژی", "بیگبنگ", "جهان", "هستی", "کیهان", "فصل", "بهار",
    "تابستان", "پاییز", "زمستان", "طبیعت", "منظره", "افق", "سپیدهدم", "گرگومیش", "نیمهشب", "ظهر", "عصر", "صبح",
    "اقیانوس", "آرام", "اطلس", "هند", "منجمد", "شمالی", "جنوبی", "دریای", "خزر", "مدیترانه", "سرخ", "کارائیب",
    "رود", "آمازون", "نیل", "یانگتسه", "میسیسیپی", "کنگو", "بیابان", "صحرای", "بزرگ", "گبی", "کالاهاری", "عربستان",
    "کوههای", "هیمالیا", "آلپ", "آند", "راکی", "اورست", "کلیمانجارو", "دماوند", "آتشفشان", "وزوو", "فوجی", "اتنا",
    "جزایر", "هاوایی", "قناری", "مالدیو", "گالاپاگوس", "جنگلهای", "آمازون", "کنگو", "بورنئو", "مواد", "معدنی",
    "کریستال", "کوارتز", "یاقوت", "زمرد", "الماس", "فیروزه", "عقیق", "مرمر", "گرانیت", "آهک",
    "بزرگ", "کوچک", "بلند", "کوتاه", "پهن", "باریک", "ضخیم", "نازک", "سنگین", "سبک", "گرم", "سرد", "داغ", "یخ",
    "زیبا", "زشت", "خوشگل", "بدگل", "جذاب", "دلربا", "دوستداشتنی", "نفرتانگیز", "خوب", "بد", "عالی", "افتضاح",
    "قوی", "ضعیف", "سالم", "بیمار", "تندرست", "ناتوان", "سریع", "آهسته", "کند", "تند", "شاد", "غمگین", "خوشحال",
    "ناراحت", "عصبانی", "آرام", "خشمگین", "مهربان", "نامهربان", "سختگیر", "آسانگیر", "باهوش", "کم هوش", "نابغه",
    "خنگ", "زرنگ", "تنبل", "کوشا", "پرتلاش", "بیخیال", "شجاع", "ترسو", "دلیر", "بزدل", "جسور", "محتاط", "صادق",
    "دروغگو", "راستگو", "فریبکار", "وفادار", "بیوفا", "خیانتکار", "بخشنده", "خسیس", "سخاوتمند", "تنگنظر", "موفق",
    "ناموفق", "پیروز", "شکستخورده", "برنده", "بازنده", "ثروتمند", "فقیر", "پولدار", "بینو", "جدید", "قدیمی",
    "کهنه", "نو", "تازه", "بیات", "جوان", "پیر", "میانسال", "نوجوان", "کودک", "نوزاد", "روشن", "تاریک", "تیره",
    "درخشان", "مات", "شفاف", "کدر", "سفید", "سیاه", "قرمز", "آبی", "زرد", "سبز", "نارنجی", "بنفش", "صورتی",
    "قهوهای", "خاکستری", "طلایی", "نقرهای", "صاف", "ناصاف", "نرم", "زبر", "خشن", "لطیف", "گرد", "مربع", "مثلث",
    "مستطیل", "دایره", "بیضی", "تیز", "کند", "شکسته", "سالم", "ترکخورده", "تمیز", "کثیف", "آلوده", "پاک", "مرتب",
    "نامرتب", "شلوغ", "خلوت", "پر", "خالی", "کامل", "ناقص", "درست", "غلط", "صحیح", "اشتباه", "مهم", "بیاهمیت",
    "ضروری", "غیرضروری", "ساده", "پیچیده", "دشوار", "آسان", "راحت", "سخت", "شیرین", "تلخ", "شور", "ترش", "بیمزه",
    "خوشمزه", "بدمزه", "تند", "ملایم", "زنده", "مرده", "بیدار", "خواب", "هوشیار", "بیهوش", "خیس", "خشک", "مرطوب",
    "نمناک", "قانونی", "غیرقانونی", "مجاز", "غیرمجاز", "رسمی", "غیررسمی", "شخصی", "عمومی", "خصوصی", "دولتی",
    "آزاد", "زندانی", "رها", "اسیر", "خطرناک", "امن", "بیخطر", "آرام", "پرسروصدا", "ساکت", "شلوغ", "خجالتی",
    "پررو", "جسور", "گستاخ", "مودب", "بیادب", "باوقار", "سبکسر", "متین", "جلف", "عاقل", "دیوانه", "مجنون", "خردمند",
    "ابله", "دانا", "نادان", "باسواد", "بیسواد", "هنرمند", "بیهنر", "خلاق", "تقلیدکار", "مبتکر", "یکنواخت", "متنوع",
    "جالب", "کسلکننده", "هیجانانگیز", "خستهکننده", "ترسناک", "وحشتناک", "آرامبخش", "استرسزا", "مفید", "مضر",
    "سودمند", "بیهوده", "گران", "ارزان", "قیمتی", "باقیمت", "رایگان", "مجانی", "مشهور", "معروف", "گمنام", "ناشناس",
    "عجیب", "غریب", "عادی", "معمولی", "نادر", "کمیاب", "فراوان", "زیاد", "کم", "اندک", "کافی", "ناکافی", "اول",
    "آخر", "ابتدایی", "نهایی", "میانی", "مرکزی", "جانبی", "داخلی", "خارجی", "بیرونی", "درونی", "بالایی", "پایینی",
    "قبلی", "بعدی", "آینده", "گذشته", "فعلی", "کنونی", "حاضر", "غایب", "واقعی", "خیالی", "مجازی", "حقیقی", "مصنوعی",
    "طبیعی", "ساختگی", "اصل", "تقلبی", "مثبت", "منفی", "خنثی", "فعال", "غیرفعال", "روشنفکر", "متعصب", "منطقی",
    "احساسی", "علمی", "تخیلی", "تاریخی", "باستانی", "مدرن", "کلاسیک", "سنتی", "محلی", "بومی", "ملی", "بینالمللی",
    "جهانی", "منطقهای", "شهری", "روستایی", "عشایری", "صنعتی", "کشاورزی", "تجاری", "اداری", "مسکونی", "آموزشی",
    "فرهنگی", "ورزشی", "سیاسی", "اقتصادی", "اجتماعی", "نظامی", "امنیتی", "قضایی", "پنهان", "آشکار", "مخفی",
    "علنی", "محرمانه", "سری", "قابل", "مشاهده", "نامرئی", "مرئی", "لاغر", "چاق", "تپل", "استخوانی", "عضلانی",
    "ورزیده", "آماده", "خسته", "سرحال", "پرانرژی", "بیحال", "غمزده", "افسرده", "شادمان", "خندان", "گریان", "متفکر",
    "نگران", "مضطرب", "آسوده", "حواسجمع", "حواس پرت", "دقیق", "بیدقت", "منظم", "بینظم", "وسواسی", "شلخته", "مغرور",
    "متواضع", "فروتن", "خودخواه", "فداکار", "ایثارگر", "حسود", "بخیل", "صبور", "عجول", "بیقرار", "شکیبا", "مصمم",
    "دودل", "بیاعتماد", "مطمئن", "مشکوک", "بدبین", "خوشبین", "واقعبین", "ایدهآلگرا", "کاملگرا", "عملگرا", "حرفهای",
    "آماتور", "باتجربه", "بیتجربه", "متخصص", "تازهکار", "ماهر", "ناشی", "توانا", "عاجز", "قدرتمند", "ضعیف", "مستقل",
    "وابسته", "تنها", "اجتماعی", "منزوی", "گوشهگیر", "برونگرا", "درونگرا", "جدی", "شوخ", "بامزه", "بینمک", "لوس",
    "بانمک", "کاریزماتیک", "الهامبخش", "افسردهکننده", "امیدوارکننده", "ناامیدکننده", "شگفتانگیز", "حیرتانگیز",
    "باورنکردنی", "عادی", "پیشپاافتاده", "استثنایی", "بی‌نظیر", "تکراری", "خالص", "ناخالص", "مخلوط", "یکدست",
    "بودن", "شدن", "داشتن", "کردن", "گفتن", "آمدن", "رفتن", "دیدن", "شنیدن", "خوردن", "نوشیدن", "خوابیدن", "بیدار",
    "ماندن", "گرفتن", "دادن", "آوردن", "بردن", "ساختن", "خراب", "شکستن", "دوختن", "پوشیدن", "خواندن", "نوشتن",
    "کشیدن", "فهمیدن", "دانستن", "توانستن", "خواستن", "بخشیدن", "بوییدن", "چشیدن", "لمس", "زدن", "افتادن", "بلند",
    "نشستن", "ایستادن", "دویدن", "پریدن", "راه", "رفتن", "خزیدن", "شنا", "پرواز", "خندیدن", "گریه", "فکر", "حرف",
    "سکوت", "نگاه", "کار", "بازی", "استراحت", "خریدن", "فروختن", "اجاره", "قرض", "پس", "پرداخت", "دریافت", "شمردن",
    "حساب", "اندازه", "گرفتن", "وزن", "بریدن", "چسباندن", "رنگ", "طراحی", "نقاشی", "عکاسی", "فیلمبرداری", "آشپزی",
    "پختن", "سرخ", "شستن", "تمیز", "مرتب", "جمع", "پهن", "تا", "باز", "بستن", "قفل", "روشن", "خاموش", "عوض", "تعمیر",
    "تغییر", "جستجو", "پیدا", "گم", "فراموش", "یادآوری", "یاد", "گرفتن", "درس", "خواندن", "آموزش", "دادن", "پرسیدن",
    "پاسخ", "جواب", "توضیح", "قبول", "رد", "دعوت", "شروع", "تمام", "ادامه", "متوقف", "صبر", "عجله", "کمک", "حمایت",
    "تشویق", "انتقاد", "قضاوت", "باور", "شک", "اعتماد", "خیانت", "عشق", "ورزیدن", "دوست", "داشتن", "متنفر", "بودن",
    "احترام", "گذاشتن", "توهین", "معذرت", "خواستن", "بخشیدن", "جنگیدن", "مبارزه", "صلح", "مذاکره", "تسلیم", "فرار",
    "پنهان", "حمله", "دفاع", "پیروز", "شکست", "خوردن", "برنده", "بازنده", "رقابت", "همکاری", "مشارکت", "رهبری",
    "دنبال", "پیروی", "سفر", "مهاجرت", "بازگشت", "ماندن", "رشد", "کوچک", "پیر", "جوان", "مردن", "متولد", "زندگی",
    "نفس", "کشیدن", "سرفه", "عطسه", "خمیازه", "لرزیدن", "عرق", "خونریزی", "درد", "کشیدن", "فریاد", "زمزمه", "آواز",
    "سوت", "جیغ", "گوش", "دادن", "صحبت", "بحث", "گفتگو", "سکوت", "وعده", "دادن", "قسم", "خوردن", "دروغ", "گفتن",
    "صداقت", "داشتن", "ساختن", "ایجاد", "خلق", "ابداع", "اختراع", "کشف", "نابود", "ویران", "منهدم", "حفظ", "نگهداری",
    "مراقبت", "رها", "ترک", "انداختن", "پرتاب", "هل", "دادن", "کشیدن", "فشار", "حمل", "گذاشتن", "برداشتن", "انتخاب",
    "سوار", "پیاده", "رانندگی", "پارک", "پرواز", "فرود", "آمدن", "شنا", "کردن", "غواصی", "بالا", "رفتن", "پایین",
    "آمدن", "وارد", "خارج", "عبور", "رد", "ایجاد", "کردن", "مخلوط", "جدا", "تقسیم", "ضرب", "جمع", "تفریق", "محاسبه",
    "حدس", "زدن", "امتحان", "تست", "آزمایش", "تجربه", "مشاهده", "بررسی", "تحقیق", "مطالعه", "کپی", "چاپ", "ارسال",
    "دریافت", "دانلود", "آپلود", "نصب", "حذف", "پاک", "ذخیره", "بازیابی", "برنامه", "ریزی", "طراحی", "تحلیل",
    "پیش", "بینی", "تصمیم", "گرفتن", "اجرا", "انجام", "دنبال", "کردن", "هدایت", "کنترل", "مدیریت", "سازماندهی",
    "قانون", "گذاری", "رای", "دادن", "انتخاب", "حکومت", "اعتراض", "تظاهرات", "انقلاب", "اصلاح", "جشن", "گرفتن",
    "عزاداری", "سوگواری", "ازدواج", "طلاق", "گرفتن", "آرزو", "کردن", "امیدوار", "بودن", "ناامید", "شدن", "ترسیدن",
    "نگران", "بودن", "آرام", "شدن", "هیجان", "زده", "شدن", "شگفت", "زده", "شدن", "خجالت", "کشیدن", "افتخار",
    "کردن", "حسادت", "کردن", "دلتنگ", "شدن", "لذت", "بردن", "رنج", "بردن", "تحمل", "کردن", "موفق", "شدن", "شکست",
    "خوردن", "تلاش", "کردن", "کوشش", "کردن", "تمرین", "کردن", "استعداد", "داشتن", "پیشرفت", "کردن", "پسرفت",
    "کردن", "ثروتمند", "شدن", "فقیر", "شدن", "معروف", "شدن", "فراموش", "شدن", "به", "دنیا", "آمدن", "از", "دنیا",
    "رفتن", "لم", "دادن", "چرت", "زدن", "رویا", "دیدن", "کابوس", "دیدن", "نالیدن", "آه", "کشیدن", "لبخند", "زدن",
    "اخم", "کردن", "پلک", "زدن", "چشمک", "زدن", "جویدن", "قورت", "دادن", "لیسیدن", "مکیدن", "تف", "کردن", "بالا",
    "آوردن", "خراشیدن", "خاراندن", "نوازش", "کردن", "بوسیدن", "بغل", "کردن", "دست", "دادن", "مشت", "زدن", "لگد", "زدن",
    "ضربه", "زدن", "بریدن", "سوراخ", "کردن", "کندن", "کاشتن", "آبیاری", "کردن", "هرس", "کردن", "برداشت", "کردن",
    "شخم", "زدن", "درو", "کردن", "بافتن", "ریسیدن", "تابیدن", "گره", "زدن", "باز", "کردن", "اتو", "کردن", "گردگیری",
    "کردن", "جارو", "کردن", "تی", "کشیدن", "گردش", "رفتن", "کوهنوردی", "کردن", "صخره", "نوردی", "کردن", "اسکی",
    "کردن", "موج", "سواری", "کردن", "قایقرانی", "کردن", "ماهیگیری", "کردن", "شکار", "کردن", "هدف", "گیری", "کردن",
    "شلیک", "کردن", "جاخالی", "دادن", "خم", "شدن", "دراز", "کشیدن", "چرخیدن", "لغزیدن", "سُر", "خوردن", "اشاره",
    "کردن", "صدا", "کردن", "دعوا", "کردن", "آشتی", "کردن", "تهمت", "زدن", "دفاع", "کردن", "شهادت", "دادن", "اعتراف",
    "کردن", "انکار", "کردن", "تهدید", "کردن", "قول", "دادن", "بدقولی", "کردن", "منتظر", "ماندن", "خداحافظی", "کردن",
    "سلام", "کردن", "معرفی", "کردن", "آشنا", "شدن", "غیبت", "کردن", "خبرچینی", "کردن", "فخرفروشی", "کردن", "پز",
    "دادن", "شکایت", "کردن", "غر", "زدن", "تحسین", "کردن", "ستایش", "کردن", "سرزنش", "کردن", "تنبیه", "کردن", "تشویق",
    "کردن", "جایزه", "دادن", "جریمه", "کردن", "حکم", "کردن", "آزاد", "کردن", "زندانی", "کردن", "تبعید", "کردن",
    "استخدام", "کردن", "اخراج", "کردن", "استعفا", "دادن", "بازنشسته", "شدن", "سرمایه", "گذاری", "کردن", "پس",
    "انداز", "کردن", "خرج", "کردن", "هدر", "دادن", "گدایی", "کردن", "دزدی", "کردن", "کلاهبرداری", "کردن", "تقلب",
    "کردن", "اثبات", "کردن", "استدلال", "کردن", "نتیجه", "گرفتن", "فرض", "کردن", "خلاصه", "کردن", "ترجمه", "کردن",
    "تفسیر", "کردن", "نقل", "قول", "کردن", "ویرایش", "کردن", "حذف", "کردن", "اضافه", "کردن", "وصل", "کردن", "قطع",
    "کردن", "روشن", "فکر", "کردن", "تاریک", "فکر", "کردن", "امضا", "کردن", "مهر", "زدن", "باطل", "کردن", "تایید",
    "کردن", "ابطال", "کردن", "صدور", "کردن", "درخواست", "کردن", "دستور", "دادن", "خواهش", "کردن", "التماس", "کردن",
    "فرمان", "دادن", "اطاعت", "کردن", "سرپیچی", "کردن", "شورش", "کردن", "قیام", "کردن", "آغاز", "کردن", "پایان",
    "دادن", "ختم", "کردن"
]

TYPING_SENTENCES = [
    "آب از سرچشمه گل آلود است",
    "آب که از سر گذشت چه یک وجب چه صد وجب",
    "آشپز که دوتا شد آش یا شور میشود یا بی نمک",
    "آفتاب همیشه پشت ابر باقی نمیماند",
    "با یک گل بهار نمیشود",
    "باد آورده را باد میبرد",
    "به عمل کار برآید به سخندانی نیست",
    "پاتو از گلیمت درازتر نکن",
    "تا نباشد چیزکی مردم نگویند چیزها",
    "تربیت نااهل را چون گردکان بر گنبد است",
    "تعارف آمد و نیامد دارد",
    "جوجه را آخر پاییز میشمارند",
    "جواب ابلهان خاموشی است",
    "چاه کن همیشه ته چاه است",
    "چیزی که عوض دارد گله ندارد",
    "حرف راست را باید از بچه شنید",
    "حساب حساب است کاکا برادر",
    "حق گرفتنی است دادنی نیست",
    "حلوا حلوا گفتن دهان را شیرین نمیکند",
    "خر همان خر است فقط پالانش عوض شده",
    "خواهی نشوی رسوا همرنگ جماعت شو",
    "خشت اول چون نهد معمار کج تا ثریا میرود دیوار کج",
    "در ناامیدی بسی امید است",
    "دست بالای دست بسیار است",
    "دشمن دانا به از نادان دوست",
    "دندان اسب پیشکشی را نمیشمارند",
    "دود از کنده بلند میشود",
    "دوری و دوستی",
    "دوستی خاله خرسه",
    "دیگ به دیگ میگه روت سیاه",
    "دیوار موش دارد موش هم گوش دارد",
    "ذره ذره جمع گردد وانگهی دریا شود",
    "زمان همه چیز را حل خواهد کرد",
    "ز گهواره تا گور دانش بجوی",
    "سحرخیز باش تا کامروا شوی",
    "سکوت علامت رضاست",
    "شاهنامه آخرش خوش است",
    "شنیدن کی بود مانند دیدن",
    "صبر اوج احترام به حکمت خداوند است",
    "عجله کار شیطان است",
    "عقل سالم در بدن سالم است",
    "علم بهتر است یا ثروت",
    "کبوتر با کبوتر باز با باز",
    "کوزه گر از کوزه شکسته آب میخورد",
    "کوه به کوه نمیرسد آدم به آدم میرسد",
    "گذشته ها گذشته",
    "گر صبر کنی ز غوره حلوا سازی",
    "ماست ها را کیسه نکن",
    "ماهی را هر وقت از آب بگیری تازه است",
    "مرغ همسایه غاز است",
    "هر آنکس که دندان دهد نان دهد",
    "هرچه پیش آید خوش آید",
    "هرکه بامش بیش برفش بیشتر",
    "هرکه طاوس خواهد جور هندوستان کشد",
    "همیشه پای یک زن در میان است",
    "هیچ گرانی بی حکمت نیست هیچ ارزانی بی علت",
    "یک دست صدا ندارد",
    "یک کلاغ چهل کلاغ",
    "آب در کوزه و ما تشنه لبان میگردیم",
    "ادب از که آموختی از بی ادبان",
    "از این ستون به آن ستون فرج است",
    "از دل برود هر آنکه از دیده برفت",
    "از کوزه همان برون تراود که در اوست",
    "اسب حیوان نجیبی است",
    "اگر برای کسی کاری انجام میدهی آن را به بهترین شکل انجام بده",
    "اندکی صبر سحر نزدیک است",
    "انسان جایز الخطاست",
    "اول چاه را بکن بعد منارش را بدزد",
    "ای که پنجاه رفت و در خوابی مگر این پنج روزه دریابی",
    "با دوستان مروت با دشمنان مدارا",
    "با ماه نشینی ماه شوی با دیگ نشینی سیاه شوی",
    "بخشندگی از بزرگان است",
    "برای همه مادر است برای ما زن بابا",
    "بزک نمیر بهار میاد کمبزه با خیار میاد",
    "بعد از هر سختی آسانی است",
    "به پایان آمد این دفتر حکایت همچنان باقیست",
    "به شتر گفتند گردنت کج است گفت کجایم راست است",
    "بهترین انتقام یک موفقیت بزرگ است",
    "بیهوده متاز که مقصد خاک است",
    "پادشاهان همیشه مدیون شجاعانند",
    "پایان شب سیه سپید است",
    "پرواز را به خاطر بسپار پرنده مردنی است",
    "پشت هر مرد موفقی یک زن قدرتمند ایستاده است",
    "پول علف خرس نیست",
    "پول خوشبختی نمی آورد اما نبودنش بدبختی می آورد",
    "تا تنور داغ است باید نان را چسباند",
    "تا سه نشه بازی نشه",
    "تجربه بالاتر از علم است",
    "تخم مرغ دزد شتر دزد میشود",
    "تدبیر کند بنده و تقدیر کند خنده",
    "تنها صداست که میماند",
    "توانا بود هر که دانا بود",
    "جایی که نمک خوردی نمکدان مشکن",
    "جنگ اول به از صلح آخر است",
    "جهان سوم جایی است که هرکس بخواهد مملکتش را آباد کند خانه اش خراب میشود",
    "چرا عاقل کند کاری که باز آرد پشیمانی",
    "چون دوستت دارد چشمت را کور میکند و چون دشمنت دارد گورت را",
    "چیزی که در جستن آنی آنی",
    "حرف مرد یکی است",
    "خدا گر ز حکمت ببندد دری ز رحمت گشاید در دیگری",
    "خدا دیرگیر است اما سخت گیر است",
    "خوشبختی توپی است که وقتی می غلتد به دنبالش میدویم و وقتی می ایستد به آن لگد میزنیم",
    "خون خون را میشوید",
    "خود کرده را تدبیر نیست",
    "در بیابان لنگه کفش کهنه هم نعمت است",
    "در خانه اگر کس است یک حرف بس است",
    "در شهر کورها یک چشم پادشاه است",
    "دست شکسته وبال گردن است",
    "دل به دل راه دارد",
    "دنیا دار مکافات است",
    "دو صد گفته چون نیم کردار نیست",
    "دوستی مثل اسناد کهنه است قدمت تاریخ آن را قیمتی میکند",
    "دیر رسیدن بهتر از هرگز نرسیدن است",
    "راه در جهان یکی است و آن راه راستی است",
    "زبان سرخ سر سبز میدهد بر باد",
    "زندگی صحنه یکتای هنرمندی ماست",
    "زکات علم نشر آن است",
    "سفره خالی بی آبرویی می آورد",
    "سگ زرد برادر شغال است",
    "شتر در خواب بیند پنبه دانه",
    "شرف المکان بالمکین",
    "عشق مانند جنگ است آسان شروع میشود اما پایان دادنش خیلی مشکل است",
    "علف باید به دهن بزی شیرین بیاد",
    "فلفل نبین چه ریزه بشکن ببین چه تیزه",
    "فکر نان کن که خربزه آب است",
    "قسمت هرچه باشد همان میشود",
    "کار نیکو کردن از پر کردن است",
    "کس نخارد پشت من جز ناخن انگشت من",
    "کفتر صناری از بقال نمیترسد",
    "کمال همنشین در من اثر کرد",
    "کم گوی و گزیده گوی چون در",
    "کهنه در برابر نو همیشه بازنده است",
    "گربه دستش به گوشت نمیرسید میگفت بو میدهد",
    "گرگ زاده عاقبت گرگ شود",
    "لقمان را گفتند ادب از که آموختی گفت از بی ادبان",
    "مار از پونه بدش می آید در لانه اش سبز میشود",
    "مار گزیده از ریسمان سیاه و سفید میترسد",
    "مال خودت را سفت نگه دار همسایه را دزد نکن",
    "مرد را دردی اگر باشد خوش است",
    "مرغی که انجیر میخوره نوکش کجه",
    "مستمع صاحب سخن را بر سر ذوق آورد",
    "مسجد نساخته گدا درش ایستاده",
    "مشک آن است که خود ببوید نه آنکه عطار بگوید",
    "موش تو سوراخ نمیرفت جارو به دمش می بست",
    "مهره مار دارد",
    "مهمان حبیب خداست",
    "می بخور منبر بسوزان مردم آزاری مکن",
    "نابرده رنج گنج میسر نمیشود",
    "نخوردیم نان گندم اما دیدیم دست مردم",
    "هر سخن جایی و هر نکته مکانی دارد",
    "هرچه سنگه مال پای لنگه",
    "هرچه کنی به خود کنی گر همه نیک و بد کنی",
    "هم خدا را میخواهد هم خرما را",
    "همسایه خوب از برادر بهتر است",
    "همیشه آب از آسیاب می افتد",
    "هیچ گربه ای برای رضای خدا موش نمیگیرد",
    "یک سوزن به خودت بزن یک جوالدوز به دیگران",
    "یکی به نعل میزنه یکی به میخ",
    "آبکش به کفگیر میگه سه سوراخ داری",
    "آدم ترسو هزار بار میمیرد",
    "از تو حرکت از خدا برکت",
    "از خرس مویی کندن غنیمت است",
    "از آب گل آلود ماهی میگیرد",
    "با حلوا حلوا کردن دهن شیرین نمیشه",
    "با پول همه کار میتوان کرد جز آنکه آن را خرج نکنی",
    "با یک تیر دو نشان زدن",
    "بالاتر از سیاهی رنگی نیست",
    "بنی آدم اعضای یکدیگرند",
    "بهترین راه پیش بینی آینده ساختن آن است",
    "پرتغال فروش را پیدا کن",
    "پشت سر مسافر آب ریختن",
    "پیش قاضی و معلق بازی",
    "تا پول داری رفیقتم قربان بند کیفتم",
    "تا عاقل بخواهد پلی پیدا کند دیوانه از رودخانه گذشته است",
    "ترس برادر مرگ است",
    "تو نیکی میکن و در دجله انداز",
    "توبه گرگ مرگ است",
    "تیرش به سنگ خورد",
    "ثوابت باشد ای دارای خرمن",
    "جامعه ای که در آن پزشک از همه بیشتر محترم باشد مردم آن جامعه بیمارند",
    "جامعه ای که در آن نظامی ها از همه محترم تر باشند مردم آن جامعه وحشی اند",
    "جایی نمیخوابه که زیرش آب بره",
    "جود بهتر از موجود",
    "چاقو دسته خودش را نمیبرد",
    "چراغی که به خانه رواست به مسجد حرام است",
    "چشمش آلبالو گیلاس میچینه",
    "چغندر به هرات زیره به کرمان میبره",
    "حوضی که ماهی نداره قورباغه سپهسالاره",
    "حرف حساب جواب نداره",
    "خراب کردن همیشه آسانتر از ساختن است",
    "خر ما از کرگی دم نداشت",
    "خلایق هرچه لایق",
    "خواهی که جهان در کف اقبال تو باشد خواهان کسی باش که خواهان تو باشد",
    "خود گویی و خود خندی عجب مرد هنرمندی",
    "خوشبختی یعنی هماهنگی با قوانین طبیعت",
    "خونش از بقیه رنگین تره",
    "درخت هرچه پربارتر باشد سرش فروتر می آید",
    "در دروازه را میتوان بست اما دهن مردم را نمیتوان",
    "دست بی هنر کفچه بی نمک است",
    "دشمن نتوان حقیر و بیچاره شمرد",
    "دزد ناشی به کاهدان میزند",
    "دزد نگرفته پادشاه است",
    "دل که پاک است زبان بی باک است",
    "دم خروس را باور کنم یا قسم حضرت عباس را",
    "دو پادشاه در یک اقلیم نگنجند",
    "دوستی بیجا خار در چشم است",
    "ده درویش در گلیمی بخسبند و دو پادشاه در اقلیمی نگنجند",
    "زبان خوش مار را از سوراخ بیرون میکشد",
    "زردآلو را میخورند برای هسته اش",
    "زندگی بدون عشق مانند کالبد بی روح است",
    "سالی که نکوست از بهارش پیداست",
    "سری که درد نمیکنه دستمال نمی بندند",
    "سنگ بزرگ علامت نزدن است",
    "سوار و پیاده با هم راه نمیروند",
    "سود و زیان خواهر و برادرند",
    "شیر بی یال و دم و اشکم که دید",
    "شیر تو شیر شدن",
    "طاس و لخت هر دو یک حکم دارند",
    "طبل تو خالیست",
    "ظالم همیشه پایدار نیست",
    "عدو شود سبب خیر اگر خدا خواهد",
    "عشق پیری گر بجنبد سر به رسوایی زند",
    "عقلش به چشمش است",
    "فرزند عزیز دردونه است",
    "فضول را به جهنم بردند گفت هیزمش تره",
    "قانون بد بهتر از بی قانونی است",
    "قدر عافیت کسی داند که به مصیبتی دچار آید",
    "قسم دروغ خانه را ویران میکند",
    "قطره قطره جمع گردد وانگهی دریا شود",
    "کار از محکم کاری عیب نمیکند",
    "کاچی بعض هیچی",
    "کف دستش را بو نکرده بود",
    "کلاغ خواست راه رفتن کبک را یاد بگیرد راه رفتن خودش را هم فراموش کرد",
    "کوه کندن و کاه جابجا کردن",
    "گاهی برای چیدن یک گل باید صد خار را تحمل کرد",
    "گدا هرچه لنگ تر اداش بیشتر",
    "گذشت زمان بهترین دارو برای هر دردی است",
    "گرگ در لباس میش",
    "گشتم نبود نگرد نیست",
    "گل همین پنج روز و شش باشد",
    "گنج و مار و گل و خار و غم و شادی به همند",
    "گوش اگر گوش تو و ناله اگر ناله من آنچه البته به جایی نرسد فریاد است",
    "لختی بهتر از بی چیزیست",
    "لذتی که در فراق است در وصال نیست",
    "لگد به بخت خود زدن",
    "مار در آستین پروراندن",
    "ماه پشت ابر نمیماند",
    "مرده را رویش را بشویی سفید میشود",
    "مرغ یک پا دارد",
    "مزد آن گرفت جان برادر که کار کرد",
    "مستی و راستی",
    "معما چو حل گشت آسان شود",
    "مغزش پاره سنگ برمیداره",
    "مفلس در اندیشه کباب است",
    "من آنچه شرط بلاغ است با تو میگویم",
    "وقت طلاست",
    "هر جا آش است کچل فراش است",
    "هر جا سنگ است به پای لنگ است",
    "هر چیز که خوار آید یک روز به کار آید",
    "هر رفتی آمدی دارد",
    "هرکه به امید همسایه نشست گرسنه میخوابد",
    "هرکه خربزه میخورد پای لرزش هم می نشیند",
    "هرکه را زر در ترازوست زور در بازوست",
    "هرکه نان از عمل خویش خورد منت حاتم طایی نبرد",
    "همه راه ها به رم ختم میشود",
    "هیچ ارزانی بی علت نیست",
    "یار بد بدتر بود از مار بد",
    "یک شبه ره صد ساله رفتن",
    "آب در دمای صفر درجه یخ میزند و در صد درجه به جوش می آید",
    "کره زمین سومین سیاره در منظومه شمسی است",
    "نور خورشید حدود هشت دقیقه طول میکشد تا به زمین برسد",
    "کهکشان راه شیری یک کهکشان مارپیچی میله ای است",
    "سیاهچاله ها مناطقی از فضا هستند که گرانش بسیار قوی دارند",
    "دی ان ای حامل اطلاعات ژنتیکی در تمام موجودات زنده است",
    "فتوسنتز فرآیندی است که گیاهان برای تبدیل نور به انرژی استفاده میکنند",
    "بزرگترین حیوان روی زمین نهنگ آبی است",
    "یوزپلنگ سریعترین حیوان خشکی است",
    "دیوار بزرگ چین از فضا با چشم غیرمسلح دیده نمیشود",
    "اهرام ثلاثه مصر در جیزه به عنوان مقبره فراعنه ساخته شدند",
    "جنگ جهانی اول در سال هزار و نهصد و چهارده آغاز شد",
    "جنگ جهانی دوم با حمله آلمان به لهستان شروع شد",
    "رنسانس دوره تحول بزرگ فرهنگی و هنری در اروپا بود",
    "انقلاب صنعتی از بریتانیا آغاز شد و جهان را تغییر داد",
    "آلبرت انیشتین نظریه نسبیت را ارائه داد",
    "اسحاق نیوتن قانون جهانی گرانش را کشف کرد",
    "ماری کوری اولین زنی بود که جایزه نوبل را دریافت کرد",
    "کوه اورست بلندترین قله جهان است",
    "رود نیل طولانی ترین رود جهان به شمار میرود",
    "جنگل آمازون بزرگترین جنگل بارانی جهان است",
    "بیابان صحرا بزرگترین بیابان گرم جهان است",
    "اقیانوس آرام بزرگترین اقیانوس سیاره ما است",
    "انسانها حدود دویست هزار سال پیش در آفریقا تکامل یافتند",
    "دایناسورها حدود شصت و شش میلیون سال پیش منقرض شدند",
    "اینترنت در ابتدا به عنوان یک پروژه نظامی در ایالات متحده توسعه یافت",
    "اولین پرواز موفق هواپیما توسط برادران رایت انجام شد",
    "واکسن آبله اولین واکسنی بود که با موفقیت ساخته شد",
    "ماه تنها قمر طبیعی سیاره زمین است",
    "مریخ به دلیل وجود اکسید آهن در سطح آن به سیاره سرخ مشهور است",
    "مشتری بزرگترین سیاره منظومه شمسی است",
    "زحل به خاطر حلقه های زیبایش شناخته میشود",
    "سرعت نور در خلا تقریبا سیصد هزار کیلومتر بر ثانیه است",
    "قلب انسان به طور متوسط صد هزار بار در روز میتپد",
    "بدن یک انسان بالغ از حدود سی و هفت تریلیون سلول تشکیل شده است",
    "خون در بدن انسان حدود شصت هزار مایل رگ خونی را طی میکند",
    "روم باستان یکی از بزرگترین امپراتوری های تاریخ بود",
    "جاده ابریشم شبکه ای از راه های تجاری برای اتصال شرق و غرب بود",
    "خط میخی یکی از قدیمی ترین سیستم های نوشتاری شناخته شده است",
    "چاپ اولین بار در چین با استفاده از قالب های چوبی اختراع شد",
    "شکسپیر به عنوان بزرگترین نویسنده زبان انگلیسی شناخته میشود",
    "لئوناردو داوینچی نقاش مجسمه ساز معمار و دانشمند بود",
    "میکل آنژ سقف کلیسای سیستین را نقاشی کرد",
    "بتهوون یکی از تاثیرگذارترین آهنگسازان تاریخ موسیقی است",
    "تمدن مایا به خاطر تقویم دقیق و معماری پیشرفته اش مشهور بود",
    "امپراتوری مغول بزرگترین امپراتوری پیوسته در تاریخ جهان بود",
    "سقوط دیوار برلین نماد پایان جنگ سرد بود",
    "آپولو یازده اولین ماموریت فضایی بود که انسان را روی ماه فرود آورد",
    "تلسکوپ فضایی هابل تصاویر شگفت انگیزی از کیهان ثبت کرده است",
    "اتم ها از پروتون نوترون و الکترون تشکیل شده اند",
    "آب مولکولی است که از دو اتم هیدروژن و یک اتم اکسیژن ساخته شده",
    "جدول تناوبی عناصر شیمیایی را بر اساس عدد اتمی آنها مرتب میکند",
    "اسیدها و بازها دو دسته مهم از ترکیبات شیمیایی هستند",
    "انرژی هسته ای از شکافت یا همجوشی هسته اتم ها آزاد میشود",
    "گرمایش جهانی به افزایش دمای متوسط زمین اشاره دارد",
    "بازیافت به کاهش زباله و حفظ منابع طبیعی کمک میکند",
    "کد مورس روشی برای انتقال پیام با استفاده از نشانه های کوتاه و بلند است",
    "جایزه نوبل هر سال به دستاوردهای برجسته در زمینه های مختلف اهدا میشود",
    "المپیک باستان در یونان به افتخار زئوس برگزار میشد",
    "کتابخانه اسکندریه یکی از بزرگترین و مهمترین کتابخانه های دنیای باستان بود",
    "ویروس ها برای تکثیر خود به سلول های میزبان نیاز دارند",
    "باکتری ها موجودات تک سلولی هستند که در همه جا یافت میشوند",
    "قارچ ها نه گیاه هستند و نه حیوان بلکه در فرمانروای خود قرار دارند",
    "خواب برای عملکرد صحیح مغز و سلامت جسمی ضروری است",
    "خنده باعث آزاد شدن اندورفین و کاهش استرس میشود",
    "ویتامین دی توسط پوست در معرض نور خورشید تولید میشود",
    "زنبورهای عسل نقش حیاتی در گرده افشانی گیاهان دارند",
    "برخی از گونه های نهنگ میتوانند بیش از دویست سال عمر کنند",
    "هشت پا دارای سه قلب و خون آبی رنگ است",
    "کلاغ ها از هوش بالایی برخوردارند و میتوانند از ابزار استفاده کنند",
    "کوسه ها قبل از دایناسورها روی زمین وجود داشته اند",
    "آتشفشان ها میتوانند آب و هوای جهانی را تحت تاثیر قرار دهند",
    "بلندترین درخت جهان یک سکویای ساحلی در کالیفرنیا است",
    "پنگوئن ها پرندگانی هستند که نمیتوانند پرواز کنند اما شناگران ماهری هستند",
    "برج ایفل برای نمایشگاه جهانی هزار و هشتصد و هشتاد و نه پاریس ساخته شد",
    "مجسمه آزادی هدیه ای از طرف مردم فرانسه به ایالات متحده بود",
    "اینترنت و شبکه جهانی وب دو مفهوم متفاوت هستند",
    "هوش مصنوعی شاخه ای از علوم کامپیوتر است که به ساخت ماشین های هوشمند میپردازد",
    "یادگیری ماشین به کامپیوترها اجازه میدهد بدون برنامه ریزی صریح یاد بگیرند",
    "بلاکچین یک دفتر کل توزیع شده و رمزنگاری شده است",
    "زبان پارسی یکی از کهن ترین زبان های جهان است که هنوز صحبت میشود",
    "فردوسی شاهنامه را در طول سی سال سرود",
    "ابن سینا یکی از بزرگترین پزشکان و فیلسوفان تاریخ بود",
    "خوارزمی پایه گذار علم جبر شناخته میشود",
    "کاغذ از چوب ساخته میشود",
    "شیشه با ذوب کردن ماسه در دمای بالا تولید میشود",
    "فولاد آلیاژی از آهن و کربن است",
    "الکتریسیته حاصل حرکت الکترون ها است",
    "آهنرباها میدان مغناطیسی تولید میکنند",
    "رنگین کمان در اثر شکست و پراکندگی نور خورشید در قطرات باران ایجاد میشود",
    "صدا در اثر ارتعاش مولکول ها در یک محیط منتقل میشود",
    "در خلا هیچ صدایی وجود ندارد زیرا محیطی برای انتقال ارتعاشات نیست",
    "چشم انسان میتواند حدود ده میلیون رنگ مختلف را تشخیص دهد",
    "اثر انگشت هر انسان منحصر به فرد است",
    "کهکشان آندرومدا نزدیکترین کهکشان بزرگ به راه شیری است",
    "فاصله زمین تا ماه حدود سیصد و هشتاد و چهار هزار کیلومتر است",
    "دمای سطح خورشید حدود پنج هزار و پانصد درجه سانتیگراد است",
    "مغز انسان پیچیده ترین ساختار شناخته شده در جهان است",
    "شطرنج یک بازی استراتژیک باستانی است که از هند سرچشمه گرفته",
    "اولین بازی ویدیویی در سال هزار و نهصد و پنجاه و هشت ساخته شد",
    "تعداد ستاره های کهکشان ما بیشتر از تعداد دانه های شن در تمام سواحل زمین است",
    "آب سنگین نوعی آب است که در آن اتم های هیدروژن با ایزوتوپ دوتریوم جایگزین شده اند",
    "عناصر رادیواکتیو به طور خود به خود واپاشی میکنند و انرژی آزاد میکنند",
    "قانون اول ترمودینامیک بیان میکند که انرژی نه ایجاد میشود و نه از بین میرود",
    "سفر در زمان از نظر تئوری امکان پذیر است اما با پارادوکس های زیادی همراه است",
    "جهان قابل مشاهده حدود نود و سه میلیارد سال نوری عرض دارد",
    "بیشتر ماده موجود در جهان ماده تاریک است که دیده نمیشود",
    "امواج گرانشی نوساناتی در تار و پود فضا زمان هستند",
    "فیزیک کوانتوم رفتار ماده و انرژی را در مقیاس اتمی و زیر اتمی توصیف میکند",
    "اصل عدم قطعیت هایزنبرگ میگوید که نمیتوان همزمان مکان و تکانه یک ذره را با دقت کامل دانست",
    "گربه شرودینگر یک آزمایش فکری برای نشان دادن مفاهیم عجیب کوانتوم است",
    "ژنتیک علم مطالعه ژن ها و وراثت است",
    "تکامل فرآیندی است که طی آن گونه های زنده در طول زمان تغییر میکنند",
    "انتخاب طبیعی مکانیزمی است که توسط داروین برای توضیح تکامل ارائه شد",
    "فسیل ها بقایای حفظ شده موجودات زنده باستانی هستند",
    "روانشناسی علم مطالعه ذهن و رفتار است",
    "جامعه شناسی به مطالعه جوامع انسانی و ساختارهای اجتماعی میپردازد",
    "اقتصاد علم تخصیص منابع کمیاب است",
    "سیاست به فعالیت های مرتبط با حکومت و قدرت میپردازد",
    "تاریخ مطالعه رویدادهای گذشته است",
    "فلسفه به بررسی سوالات بنیادین درباره وجود دانش و اخلاق میپردازد",
    "هنر بیان خلاقانه ایده ها و احساسات انسانی است",
    "موسیقی ترکیبی از صدا و سکوت در طول زمان است",
    "ادبیات شامل آثار نوشتاری مانند شعر رمان و نمایشنامه است",
    "معماری هنر و علم طراحی و ساخت بناها است",
    "کره ماه هیچ اتمسفری ندارد",
    "ونوس گرمترین سیاره منظومه شمسی است",
    "اورانوس به پهلو میخوابد و میچرخد",
    "نپتون دورترین سیاره از خورشید است",
    "پلوتو در سال دوهزار و شش به عنوان یک سیاره کوتوله طبقه بندی شد",
    "سیارک ها اجرام سنگی کوچکی هستند که به دور خورشید میگردند",
    "دنباله دارها گلوله های برفی کیهانی از گاز یخ و غبار هستند",
    "باران شهابی زمانی رخ میدهد که زمین از میان بقایای یک دنباله دار عبور کند",
    "خورشید گرفتگی زمانی اتفاق می افتد که ماه بین زمین و خورشید قرار گیرد",
    "ماه گرفتگی زمانی رخ میدهد که زمین بین خورشید و ماه قرار گیرد",
    "جزر و مد عمدتا ناشی از نیروی گرانش ماه است",
    "پوست بزرگترین عضو بدن انسان است",
    "کبد بیش از پانصد عملکرد حیاتی در بدن دارد",
    "کلیه ها مواد زائد را از خون تصفیه میکنند",
    "ریه ها وظیفه تبادل اکسیژن و دی اکسید کربن را بر عهده دارند",
    "سیستم ایمنی بدن را در برابر عوامل بیماری زا محافظت میکند",
    "عصب ها پیام ها را بین مغز و بقیه بدن منتقل میکنند",
    "هورمون ها پیام رسان های شیمیایی در بدن هستند",
    "آنزیم ها پروتئین هایی هستند که واکنش های شیمیایی را تسریع میکنند",
    "کربوهیدرات ها منبع اصلی انرژی برای بدن هستند",
    "پروتئین ها برای ساخت و ترمیم بافت ها ضروری هستند",
    "چربی ها برای جذب ویتامین ها و تولید هورمون ها لازمند",
    "ویتامین ها ترکیبات آلی مورد نیاز برای سلامتی هستند",
    "مواد معدنی عناصر غیرآلی هستند که در فرآیندهای بدن نقش دارند",
    "آب برای تمام عملکردهای حیاتی بدن ضروری است",
    "خورشید به آرامی در پشت کوه ها پنهان میشد",
    "صدای امواج خروشان دریا آرامشی عجیب داشت",
    "باد در میان شاخه های خشکیده درختان میپیچید",
    "ماه کامل آسمان تاریک شب را مانند یک الماس روشن کرده بود",
    "سکوت شب را صدای جیرجیرک ها میشکست",
    "عطر گلهای بهاری در فضا پیچیده بود",
    "برگهای پاییزی مانند فرشی رنگارنگ زمین را پوشانده بودند",
    "دانه های برف به آرامی بر روی زمین مینشستند",
    "چشمانش داستانی ناگفته را در خود پنهان داشت",
    "لبخندی زد که تمام غصه هایم را از یاد بردم",
    "صدایش مانند موسیقی دلنوازی در گوشم طنین انداز شد",
    "در عمق نگاهش جهانی از رمز و راز نهفته بود",
    "خاطرات گذشته مانند فیلمی از جلوی چشمانم عبور کرد",
    "زمان در آن لحظه برای همیشه متوقف شده بود",
    "قلبم با هر تپش نام تو را فریاد میزد",
    "آرزوهایم را در آسمان شب به ستاره ها گفتم",
    "جاده ای طولانی و بی انتها در پیش رو داشتیم",
    "سایه ها در نور غروب بلندتر و کشیده تر میشدند",
    "امید مانند شمعی کوچک در تاریکی میدرخشید",
    "آینده مانند کتابی نانوشته در مقابل ما قرار دارد",
    "کلمات قدرتی دارند که میتوانند دنیا را تغییر دهند",
    "هر انسان داستانی منحصر به فرد برای گفتن دارد",
    "زندگی سفری کوتاه در مسیری بی پایان است",
    "عشق زبانی است که نیاز به مترجم ندارد",
    "دوستی گنجی است که با هیچ ثروتی قابل مقایسه نیست",
    "باران خاطرات فراموش شده را دوباره زنده میکرد",
    "دریا رازهای بسیاری را در دل خود نگه داشته است",
    "کویر با سکوت پرمعنای خود سخن میگوید",
    "جنگل خانه هزاران موجود زنده است",
    "آسمان دفتر نقاشی بی انتهای خداوند است",
    "هر طلوع آغازی دوباره برای زندگی است",
    "غروب خورشید پایانی زیبا بر یک روز پر تلاش است",
    "رویاها پنجره ای به سوی دنیای درون ما هستند",
    "اشک ها کلماتی هستند که قلب نمیتواند بیان کند",
    "شجاعت ترس نداشتن نیست بلکه عمل کردن با وجود ترس است",
    "بخشش هدیه ای است که به خودمان میدهیم",
    "صداقت زیباترین زینت یک انسان است",
    "مهربانی پلی است که قلب ها را به هم متصل میکند",
    "موفقیت نتیجه تلاش های کوچک و مداوم است",
    "شکست پله ای برای رسیدن به پیروزی است",
    "خاطره تنها چیزی است که هیچکس نمیتواند از ما بگیرد",
    "هنر راهی برای بیان احساساتی است که در کلمات نمیگنجد",
    "موسیقی غذای روح است و به آن آرامش میبخشد",
    "کتاب ها بهترین دوستانی هستند که هرگز ما را ترک نمیکنند",
    "دانش قدرتی است که میتواند سرنوشت را تغییر دهد",
    "تخیل مهمتر از دانش است زیرا دانش محدود است",
    "تغییر تنها پدیده ثابت در جهان هستی است",
    "برای دیدن رنگین کمان باید باران را تحمل کرد",
    "یک سفر هزار کیلومتری با اولین قدم آغاز میشود",
    "ساده زیستن هنری است که نیاز به تمرین دارد",
    "شادی در داشتن چیزهای زیاد نیست بلکه در لذت بردن از چیزهای کوچک است",
    "حقیقت مانند خورشید است که نمیتوان آن را برای همیشه پنهان کرد",
    "وجدان قطب نمایی است که راه درست را به ما نشان میدهد",
    "ایمان کوه ها را جابجا میکند",
    "دعای مادر کلید درهای بسته است",
    "صبر درختی است که میوه اش شیرین است",
    "جوانی دوره ای است که باید آن را غنیمت شمرد",
    "پیری گنجینه ای از تجربیات گرانبهاست",
    "مرگ تنها حقیقتی است که همه در برابر آن یکسان هستند",
    "خداوند در جزئیات پنهان است",
    "انسان موجودی است که همیشه به دنبال معنا میگردد",
    "فلسفه تلاش برای فهمیدن جهان و جایگاه ما در آن است",
    "تاریخ تکرار اشتباهات انسانهاست",
    "آزادی بزرگترین نعمتی است که یک ملت میتواند داشته باشد",
    "عدالت پایه و اساس یک جامعه سالم است",
    "صلح آرزوی همیشگی تمام انسانهاست",
    "جنگ ویرانگرترین پدیده ساخت دست بشر است",
    "علم چراغی است که تاریکی جهل را از بین میبرد",
    "فناوری شمشیری دو لبه است که میتواند هم مفید و هم مضر باشد",
    "طبیعت بهترین معلم برای انسان است",
    "سکوت گاهی اوقات رساتر از هزاران فریاد است",
    "تنهایی فرصتی برای شناخت بهتر خود است",
    "خانواده اولین و مهمترین نهاد اجتماعی است",
    "کودکی دنیای رنگارنگ رویاها و بازی هاست",
    "نوجوانی دوران طوفانی تغییر و تحول است",
    "عمر کوتاهتر از آن است که آن را صرف کینه و نفرت کنیم",
    "یک لبخند میتواند روز کسی را به کلی تغییر دهد",
    "آینده متعلق به کسانی است که به زیبایی رویاهایشان ایمان دارند",
    "هیچگاه برای یادگیری دیر نیست",
    "هر روز فرصتی دوباره برای بهتر شدن است",
    "ذهن انسان مانند یک باغ است هرچه در آن بکاری همان را درو میکنی",
    "زیبایی واقعی در درون انسانها نهفته است نه در ظاهر آنها",
    "راز خوشبختی در بخشیدن است نه در گرفتن",
    "کسانی که دنیا را تغییر میدهند دیوانه هایی هستند که باور دارند میتوانند",
    "برای پرواز کردن نیازی به بال نیست داشتن اراده کافیست",
    "یک شمع میتواند هزاران شمع دیگر را روشن کند بدون آنکه از عمرش کاسته شود",
    "بهترین راه برای پیش بینی آینده ساختن آن است",
    "سفر روح را تازه میکند و دید را گسترش میدهد",
    "هنر زبان جهانی بشریت است",
    "یک عکس میتواند بیشتر از هزار کلمه سخن بگوید",
    "هر پایانی میتواند یک شروع جدید باشد",
    "زندگی مانند یک رودخانه است همیشه در جریان است",
    "قدر لحظه حال را بدان چون دیگر هرگز تکرار نمیشود",
    "انسانهای بزرگ درباره ایده ها صحبت میکنند",
    "انسانهای متوسط درباره رویدادها صحبت میکنند",
    "انسانهای کوچک درباره دیگران صحبت میکنند",
    "شادی مسری است آن را به دیگران نیز منتقل کنید",
    "یک دوست واقعی در روزهای سخت شناخته میشود",
    "اعتماد مانند یک کاغذ است اگر مچاله شود دیگر هرگز صاف نخواهد شد",
    "حقیقت ممکن است تلخ باشد اما همیشه شفابخش است",
    "هدف داشتن در زندگی به انسان انگیزه حرکت میدهد",
    "تلاش بدون هدف مانند دویدن روی تردمیل است",
    "برای رسیدن به قله باید سختی های مسیر را تحمل کرد",
    "هیچ موفقیتی یک شبه به دست نمی آید",
    "بزرگترین شکست تلاش نکردن است",
    "از اشتباهات خود درس بگیرید و آنها را تکرار نکنید",
    "دنیا پر از شگفتی هایی است که باید آنها را کشف کرد",
    "کنجکاوی اولین قدم در مسیر یادگیری است",
    "یک گفتگو صادقانه میتواند بسیاری از مشکلات را حل کند",
    "گاهی اوقات بهترین پاسخ سکوت کردن است",
    "به ندای قلب خود گوش فرا دهید او راه را به شما نشان میدهد",
    "هر کس در زندگی رسالتی بر عهده دارد",
    "خودت را با دیگران مقایسه نکن تو در مسیر منحصر به فرد خودت هستی",
    "مهم نیست چقدر آهسته حرکت میکنی تا زمانی که متوقف نشوی",
    "قدرت واقعی در کنترل خود است نه در کنترل دیگران",
    "یک ذهن آرام میتواند قوی ترین طوفان ها را پشت سر بگذارد",
    "زیبایی در سادگی نهفته است",
    "مهربانی زبانی است که ناشنوایان میشنوند و نابینایان میبینند",
    "گذشته را نمیتوان تغییر داد اما آینده هنوز در دستان توست",
    "امید چراغی است که در تاریک ترین شبها نیز میدرخشد",
    "شکرگزاری کلید فراوانی و نعمت است",
    "قلبی که میبخشد همیشه جوان میماند",
    "خاطرات شیرین گنجینه های ذهن هستند",
    "یک کتاب خوب میتواند دیدگاه انسان را به کل دنیا تغییر دهد",
    "موفقیت یعنی رفتن از شکستی به شکست دیگر بدون از دست دادن اشتیاق",
    "تنها محدودیت های زندگی آنهایی هستند که خودمان میسازیم",
    "به جای پیدا کردن خودت سعی کن خودت را بسازی",
    "اگر میخواهی دنیا را تغییر دهی از خودت شروع کن",
    "شجاعت مقاومت در برابر ترس است نه نبود ترس",
    "یک رهبر واقعی راه را میداند راه را میرود و راه را نشان میدهد",
    "شادی یک مقصد نیست بلکه یک مسیر است",
    "فرصت ها مانند طلوع خورشید هستند اگر زیاد صبر کنی آنها را از دست میدهی",
    "با افکار مثبت دنیای خود را زیباتر کن",
    "دانش بدون عمل مانند ابری بی باران است",
    "یک قلب مهربان از تمام معابد دنیا مقدس تر است",
    "زندگی یک بوم نقاشی است آن را با رنگ های شاد رنگ آمیزی کن",
    "فقط کسانی که جرات شکست خوردن دارند طعم پیروزی را میچشند",
    "هیچ چیز ارزشمندی به آسانی به دست نمی آید",
    "آرامش را در درون خودت پیدا کن نه در دنیای بیرون",
    "برای رسیدن به نور باید از تاریکی عبور کرد",
    "هرگز قدرت یک لبخند ساده را دست کم نگیر",
    "بهترین زمان برای کاشتن یک درخت بیست سال پیش بود دومین زمان همین امروز است",
    "خوشبختی در رضایت از داشته هاست",
    "یک دوست خوب آینه ای از بهترین نسخه توست",
    "هدف گذاری اولین قدم برای تبدیل نادیدنی ها به دیدنی هاست",
    "راز پیشرفت شروع کردن است",
    "اجازه نده دیروز بخش زیادی از امروز تو را به خود اختصاص دهد",
    "تنها راه انجام کارهای بزرگ دوست داشتن آن کار است",
    "استعداد ذاتی فقط یک شروع است باید با تلاش آن را پرورش دهی",
    "تمرین زیاد باعث میشود کارهای سخت آسان به نظر برسند",
    "راز شاد زیستن در لذت بردن از چیزهای کوچک است",
    "بخشیدن دیگران به معنای ساختن آینده ای بهتر است",
    "هرگز برای تبدیل شدن به آن کسی که میتوانستی باشی دیر نیست",
    "فوتبال محبوب ترین ورزش در سراسر جهان است",
    "جام جهانی فوتبال هر چهار سال یکبار برگزار میشود",
    "تیم ملی ما برای صعود به مرحله بعد تلاش میکند",
    "دروازه بان با یک واکنش سریع تیمش را نجات داد",
    "مهاجم با یک شوت دقیق توپ را وارد دروازه کرد",
    "داور به دلیل خطا یک کارت زرد به بازیکن نشان داد",
    "تماشاگران با شور و هیجان تیم خود را تشویق میکردند",
    "بسکتبال ورزشی است که نیاز به قد بلند و مهارت بالا دارد",
    "پرتاب سه امتیازی میتواند سرنوشت بازی را تغییر دهد",
    "لیگ ان بی ای معتبرترین لیگ بسکتبال جهان است",
    "والیبال یک ورزش گروهی است که در آن همکاری اهمیت زیادی دارد",
    "سرویس پرشی یکی از تکنیک های مهم در والیبال مدرن است",
    "دفاع روی تور برای جلوگیری از حمله حریف ضروری است",
    "کشتی یکی از قدیمی ترین ورزش های جهان به شمار میرود",
    "کشتی گیران در دو سبک آزاد و فرنگی با هم رقابت میکنند",
    "وزنه برداری ورزشی قدرتی برای بلند کردن سنگین ترین وزنه هاست",
    "حرکت یک ضرب و دو ضرب دو بخش اصلی وزنه برداری هستند",
    "دو و میدانی مادر همه ورزش ها نامیده میشود",
    "دو سرعت پرش طول و پرتاب نیزه از رشته های دو و میدانی هستند",
    "مسابقات المپیک بزرگترین رویداد ورزشی جهان است",
    "مدال طلا بالاترین افتخار برای هر ورزشکاری است",
    "تنیس یک ورزش راکتی است که به صورت انفرادی یا دو نفره بازی میشود",
    "مسابقات گرند اسلم مهمترین رویدادهای دنیای تنیس هستند",
    "شنا ورزشی کامل است که تمام عضلات بدن را درگیر میکند",
    "شنای کرال سینه قورباغه و پروانه از سبک های اصلی شنا هستند",
    "ژیمناستیک ورزشی است که به انعطاف و قدرت بدنی بالایی نیاز دارد",
    "کوهنوردی ورزشی ماجراجویانه برای صعود به قله های بلند است",
    "اسکی ورزشی زمستانی است که بر روی برف انجام میشود",
    "موج سواری ورزشی آبی برای حرکت بر روی امواج دریاست",
    "بوکس یک ورزش رزمی است که در آن دو نفر با دستکش مبارزه میکنند",
    "هنرهای رزمی ترکیبی مانند ام ام ای محبوبیت زیادی پیدا کرده اند",
    "کاراته جودو و تکواندو از هنرهای رزمی معروف هستند",
    "ورزش منظم برای سلامت جسم و روان ضروری است",
    "گرم کردن قبل از ورزش از آسیب دیدگی جلوگیری میکند",
    "سرد کردن بعد از ورزش به بازگشت بدن به حالت اولیه کمک میکند",
    "تغذیه مناسب نقش مهمی در عملکرد ورزشکاران دارد",
    "روحیه ورزشی یعنی احترام به حریف و پذیرش شکست",
    "کار گروهی کلید موفقیت در ورزش های تیمی است",
    "مربی نقش مهمی در هدایت و آموزش ورزشکاران دارد",
    "داوری عادلانه برای برگزاری یک مسابقه سالم ضروری است",
    "هواداران یار دوازدهم تیم در زمین مسابقه هستند",
    "استادیوم ورزشی محلی برای برگزاری مسابقات و تشویق تیم هاست",
    "رکورد جهانی بالاترین عملکرد ثبت شده در یک رشته ورزشی است",
    "پارالمپیک مسابقاتی برای ورزشکاران دارای معلولیت جسمی است",
    "شطرنج یک ورزش فکری و استراتژیک به شمار میرود",
    "حرکت کیش و مات به معنای پایان بازی شطرنج است",
    "فرمول یک اوج مسابقات اتومبیل رانی در جهان است",
    "رانندگان فرمول یک به سرعت های بسیار بالایی دست پیدا میکنند",
    "دوچرخه سواری یک ورزش و همچنین یک وسیله حمل و نقل پاک است",
    "تور دو فرانس معتبرترین مسابقه دوچرخه سواری جاده ای است",
    "بیسبال و فوتبال آمریکایی در ایالات متحده بسیار محبوب هستند",
    "راگبی ورزشی گروهی و پربرخورد است",
    "کریکت در کشورهای مشترک المنافع طرفداران زیادی دارد",
    "گلف ورزشی است که در آن بازیکنان با چوب به توپ ضربه میزنند",
    "بیلیارد و اسنوکر ورزش هایی هستند که نیاز به دقت و تمرکز بالا دارند",
    "تیراندازی با کمان ورزشی باستانی است که دقت بالایی میطلبد",
    "سوارکاری هنر و ورزش کنترل اسب است",
    "قایقرانی ورزشی آبی است که در رشته های مختلف انجام میشود",
    "پینگ پنگ یا تنیس روی میز نیاز به واکنش های سریع دارد",
    "بدمینتون سریعترین ورزش راکتی جهان است",
    "هندبال یک ورزش تیمی سریع و پرگل است",
    "هاکی روی یخ ورزشی بسیار سریع و فیزیکی است",
    "صخره نوردی ورزشی چالش برانگیز برای بالا رفتن از دیواره های سنگی است",
    "یوگا ترکیبی از حرکات فیزیکی تنفس و مدیتیشن است",
    "پیلاتس برای تقویت عضلات مرکزی بدن بسیار مفید است",
    "بدنسازی و پرورش اندام برای افزایش حجم و قدرت عضلات انجام میشود",
    "فوتبال ساحلی بر روی شن و ماسه بازی میشود",
    "فوتسال نسخه پنج نفره فوتبال در سالن است",
    "واترپلو ورزشی گروهی است که در آب برگزار میشود",
    "اسکیت و اسکیت بورد ورزش های محبوبی در میان جوانان هستند",
    "پارکور هنر جابجایی سریع و کارآمد در محیط های شهری است",
    "پینت بال یک بازی گروهی است که در آن با گلوله های رنگی به هم شلیک میکنند",
    "دارت ورزشی است که نیاز به تمرکز و هماهنگی چشم و دست دارد",
    "بولینگ ورزشی تفریحی برای انداختن توپ و زدن پین ها است",
    "ورزش های الکترونیک به رقابت های حرفه ای بازی های ویدیویی گفته میشود",
    "استقامت و پشتکار دو عامل مهم برای موفقیت در ورزش هستند",
    "پیروزی در یک مسابقه نتیجه ماه ها تمرین و تلاش است",
    "شکست در ورزش فرصتی برای یادگیری و قوی تر شدن است",
    "هیجان تماشای یک مسابقه ورزشی زنده بی نظیر است",
    "ورزش کردن به افزایش اعتماد به نفس کمک میکند",
    "قهرمانان ورزشی الگوهای خوبی برای جوانان هستند",
    "بازی جوانمردانه یکی از اصول اساسی در ورزش است",
    "استفاده از دوپینگ در ورزش تقلب محسوب میشود",
    "المپیک زمستانی هر چهار سال یکبار برگزار میشود",
    "هاکی روی چمن در بسیاری از کشورها محبوب است",
    "فریزبی یک ورزش و سرگرمی محبوب در پارک ها است",
    "اسکواش یک ورزش راکتی پرتحرک است که در یک اتاق بسته بازی میشود",
    "گلبال ورزشی برای افراد نابینا و کم بینا است",
    "پرش با نیزه یکی از جذاب ترین رشته های دو و میدانی است",
    "دهگانه و هفتگانه آزمون های جامع برای ورزشکاران دو و میدانی هستند",
    "ماراتن یک مسابقه دوی استقامت به مسافت حدود چهل و دو کیلومتر است",
    "قویترین مردان رقابتی برای نمایش قدرت بدنی فوق العاده است"
]

# --- دیکشنری توضیحات بازی‌ها برای پنل راهنما ---
GAME_DESCRIPTIONS = {
    "hokm": "بازی کارتی محبوب و استراتژیک حکم که به صورت ۲ یا ۴ نفره قابل اجراست. تلاش کنید با برنده شدن در دست‌ها، به امتیاز ۷ برسید.",
    "dooz": "بازی کلاسیک دوز (XO) به صورت دو نفره. اولین کسی که سه مهره خود را در یک ردیف افقی، عمودی یا مورب قرار دهد، برنده است.",
    "doz4p": "نسخه هیجان‌انگیزتر بازی دوز به صورت چهار نفره. برای برنده شدن باید ۴ مهره را در یک ردیف قرار دهید.",
    "connect4": "بازی استراتژیک 'چهار در یک ردیف'. بازیکنان به نوبت مهره‌های خود را از بالا به داخل ستون‌ها می‌اندازند و اولین کسی که یک ردیف چهارتایی بسازد، برنده است.",
    "rps": "بازی کلاسیک سنگ، کاغذ، قیچی. انتخاب خود را مخفیانه انجام دهید و ببینید چه کسی برنده می‌شود!",
    "memory": "حافظه خود را به چالش بکشید! کارت‌ها را دو به دو برگردانید و سعی کنید جفت‌های یکسان را پیدا کنید. بازیکنی که بیشترین جفت را پیدا کند، برنده است.",
    "hads_kalame": "یک کلمه مخفی می‌شود و شما باید با حدس حروف، آن را پیدا کنید. هر کاربر تعداد جان مشخصی دارد!",
    "type_speed": "یک جمله نمایش داده می‌شود و اولین کسی که آن را سریع و درست تایپ کند، برنده مسابقه سرعت خواهد بود.",
    "hads_addad": "(ویژه ادمین) ادمین یک بازه عددی مشخص می‌کند و ربات عددی را انتخاب می‌کند. بقیه باید سعی کنند با راهنمایی‌های 'بالاتر' و 'پایین‌تر'، عدد را پیدا کنند.",
    "2048": "یک بازی تک‌نفره فکری. با حرکت دادن خانه‌ها، اعداد یکسان را با هم ترکیب کنید تا به عدد 2048 برسید.",
    "spuzzle": "بازی پازل کشویی (Sliding Puzzle). اعداد به هم ریخته را مرتب کنید تا به ترتیب صحیح از ۱ تا ۱۵ برسند.",
    "samegame": "بازی فکری جفت‌ها. روی گروه‌هایی از بلوک‌های همرنگ (حداقل ۲ تایی) کلیک کنید تا حذف شوند و امتیاز بگیرید.",
    "eteraf": "(ویژه ادمین) ادمین یک موضوع برای اعتراف ایجاد می‌کند و اعضای گروه به صورت کاملاً ناشناس به آن پاسخ می‌دهند.",
    "gharch": "(ویژه ادمین) در این بازی ناشناس، ادمین یک 'گاد' تعیین می‌کند. پیام‌های ناشناس اعضا فقط برای 'گاد' فاش می‌شود.",
    "gardone": "(ویژه ادمین) یک گردونه شانس یا قرعه‌کشی بین اعضای گروه ایجاد کنید. اعضا پس از عضویت در کانال می‌توانند به گردونه بپیوندند."
}

SAMEGAME_WIDTH, SAMEGAME_HEIGHT = 10, 10
SAMEGAME_COLORS = ["🟥", "🟩", "🟦", "🟨", "🟪"]
EMPTY_CELL = "⬛️" # یا هر اموجی دیگری که برای خانه خالی می‌پسندید

# (این را کنار بقیه لیست‌ها مثل WORD_LIST قرار دهید)
NUMBER_EMOJIS = ["1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "🔟", "1️⃣1️⃣", "1️⃣2️⃣", "1️⃣3️⃣"]

# --- تنظیمات لاگ ---
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# --- مدیریت دیتابیس (بدون تغییر) ---
DATABASE_URL = os.environ.get("DATABASE_URL")
def get_db_connection():
    try: return psycopg2.connect(DATABASE_URL)
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return None

def setup_database():
    conn = get_db_connection()
    if conn:
        try:
            with conn.cursor() as cur:
                cur.execute("CREATE TABLE IF NOT EXISTS users (user_id BIGINT PRIMARY KEY, first_name VARCHAR(255), username VARCHAR(255), start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW());")
                cur.execute("CREATE TABLE IF NOT EXISTS groups (group_id BIGINT PRIMARY KEY, title VARCHAR(255), member_count INT, added_time TIMESTAMP WITH TIME ZONE DEFAULT NOW());")
                cur.execute("CREATE TABLE IF NOT EXISTS start_message (id INT PRIMARY KEY, message_id BIGINT, chat_id BIGINT);")
                cur.execute("CREATE TABLE IF NOT EXISTS banned_users (user_id BIGINT PRIMARY KEY);")
                cur.execute("CREATE TABLE IF NOT EXISTS banned_groups (group_id BIGINT PRIMARY KEY);")
            conn.commit()
            logger.info("Database setup complete.")
        except Exception as e: logger.error(f"Database setup failed: {e}")
        finally: conn.close()

# --- توابع کمکی ---
async def is_owner(user_id: int) -> bool: return user_id in OWNER_IDS
async def is_group_admin(user_id: int, chat_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    if await is_owner(user_id): return True
    admins = await context.bot.get_chat_administrators(chat_id)
    return user_id in {admin.user.id for admin in admins}
def convert_persian_to_english_numbers(text: str) -> str:
    if not text: return ""
    return text.translate(str.maketrans("۰۱۲۳۴۵۶۷۸۹", "0123456789"))

# --- مدیریت وضعیت بازی‌ها ---
active_games = {'guess_number': {}, 'dooz': {}, 'hangman': {}, 'typing': {}, 'hokm': {}, 'connect4': {}, 'rps': {}, 'memory': {}, '2048': {}, 'samegame': {}, 'spuzzle': {}, 'doz4p': {}, 'gardone': {}}
active_gharch_games = {}

# --- ##### تغییر کلیدی: منطق جدید عضویت اجباری و بن ##### ---
async def check_ban_status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """چک می‌کند که آیا کاربر یا گروه بن شده است یا خیر. اگر گروه بن باشد، ربات خارج می‌شود."""
    user = update.effective_user
    chat = update.effective_chat
    if not user: return True # اگر کاربری وجود نداشت، بن شده در نظر بگیر

    conn = get_db_connection()
    if not conn: return False # اگر دیتابیس وصل نشد، فرض بر عدم بن بودن است
    
    is_banned = False
    try:
        with conn.cursor() as cur:
            cur.execute("SELECT 1 FROM banned_users WHERE user_id = %s;", (user.id,))
            if cur.fetchone():
                is_banned = True
            
            if not is_banned and chat.type != 'private':
                cur.execute("SELECT 1 FROM banned_groups WHERE group_id = %s;", (chat.id,))
                if cur.fetchone():
                    is_banned = True
                    try:
                        await context.bot.leave_chat(chat.id)
                    except Exception:
                        pass
    except Exception as e:
        logger.error(f"Error checking ban status: {e}")
    finally:
        conn.close()
    
    return is_banned

async def check_join_for_alert(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """
    این تابع فقط برای **پیوستن** به بازی‌های کارتی استفاده می‌شود و در صورت عدم عضویت، الرت می‌دهد.
    """
    user = update.effective_user
    if not user or await is_owner(user.id):
        return True

    try:
        member = await context.bot.get_chat_member(chat_id=FORCED_JOIN_CHANNEL, user_id=user.id)
        if member.status in ['member', 'administrator', 'creator']:
            return True
    except Exception as e:
        logger.warning(f"Could not check channel membership for alert: {user.id}: {e}")

    if update.callback_query:
        await update.callback_query.answer(
            "برای پیوستن به بازی باید در کانال عضو شوید",
            show_alert=True
        )
    return False

async def check_forced_join(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """
    عضویت کاربر در کانال را چک می‌کند. اگر عضو نباشد، پیام عضویت ارسال کرده و False برمی‌گرداند.
    این تابع فقط برای بازی‌هایی که نیاز به عضویت دارند استفاده می‌شود.
    """
    user = update.effective_user
    if not user or await is_owner(user.id):
        return True

    try:
        member = await context.bot.get_chat_member(chat_id=FORCED_JOIN_CHANNEL, user_id=user.id)
        if member.status in ['member', 'administrator', 'creator']:
            return True
    except Exception as e:
        logger.warning(f"Could not check channel membership for {user.id}: {e}")

    keyboard = [[InlineKeyboardButton(" عضویت در کانال ", url=f"https://t.me/{FORCED_JOIN_CHANNEL.lstrip('@')}")]]
    text = f"❗️{user.mention_html()}، برای استفاده از این بخش ابتدا باید در کانال ما عضو شوی."
    
    # تشخیص اینکه پاسخ به پیام باشد یا به کلیک روی دکمه
    if update.callback_query:
        await update.callback_query.answer(
            " @RHINOSOUL_TM برای ادامه بازی باید در کانال عضو شوید",
            show_alert=True
        )
    elif update.message:
        await update.message.reply_text(
            text, 
            reply_markup=InlineKeyboardMarkup(keyboard), 
            parse_mode=ParseMode.HTML
        )
        
    return False

async def rsgame_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """دستور اصلی برای نمایش پنل بازی‌ها با بررسی اولیه عضویت و به صورت اختصاصی."""
    if await check_ban_status(update, context):
        return
    
    user = update.effective_user
    user_id = user.id
    chat_id = update.effective_chat.id
    is_member = False

    # بخش بررسی عضویت
    if await is_owner(user_id):
        is_member = True
    else:
        try:
            member = await context.bot.get_chat_member(chat_id=FORCED_JOIN_CHANNEL, user_id=user_id)
            if member.status in ['member', 'administrator', 'creator']:
                is_member = True
        except Exception:
            is_member = False

    # --- ساختار صحیح و اصلاح شده IF/ELSE ---

    if is_member:
        # ۱. اگر کاربر عضو است، پنل اصلی را نمایش بده
        text = f"🎮 {user.first_name} عزیز، به پنل بازی خوش آمدید.\n\nلطفا دسته بندی مورد نظر خود را انتخاب کنید:"
        
        keyboard = [
            [
                InlineKeyboardButton("👤 بازی‌های تک‌نفره", callback_data=f"rsgame_cat_single_{user_id}"),
                InlineKeyboardButton("🏆 بازی‌های گروهی", callback_data=f"rsgame_cat_board_{user_id}")
            ],
            [
                InlineKeyboardButton("✍️ بازی‌های تایپی", callback_data=f"rsgame_cat_typing_{user_id}"),
                InlineKeyboardButton("🤫 بازی‌های ناشناس", callback_data=f"rsgame_cat_anon_{user_id}")
            ]
        ]

        if update.effective_chat.type != 'private':
            if await is_group_admin(user_id, chat_id, context):
                keyboard.append([InlineKeyboardButton("🎡 گردونه شانس (ویژه ادمین)", callback_data=f"gardone_start_{user_id}")])
        
        keyboard.append([InlineKeyboardButton("✖️ بستن پنل", callback_data=f"rsgame_close_{user_id}")])
        
        # بررسی اینکه آیا باید پیام جدید ارسال شود یا پیام قبلی ویرایش شود
        if update.message:
            await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        elif update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

    else:
        # ۲. اگر کاربر عضو نیست، پنل عضویت را نمایش بده
        text = "❗️برای استفاده از بازی‌ها، لطفا ابتدا در کانال ما عضو شوید و سپس دکمه «عضو شدم» را بزنید."
        keyboard = [
            [InlineKeyboardButton("عضویت در کانال", url=f"https://t.me/{FORCED_JOIN_CHANNEL.lstrip('@')}")],
            [InlineKeyboardButton("✅ عضو شدم", callback_data="rsgame_check_join")]
        ]
        
        if update.message:
            await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        elif update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def rsgame_check_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """بررسی مجدد عضویت پس از کلیک روی دکمه 'عضو شدم'."""
    query = update.callback_query
    user = query.from_user
    
    try:
        member = await context.bot.get_chat_member(chat_id=FORCED_JOIN_CHANNEL, user_id=user.id)
        if member.status in ['member', 'administrator', 'creator']:
            await query.answer("عضویت شما تایید شد!")
            # حالا که عضویت تایید شد، پنل اصلی را به او نشان می‌دهیم
            await rsgame_command(update, context)
        else:
            await query.answer("شما هنوز در کانال عضو نشده‌اید!", show_alert=True)
    except Exception:
        await query.answer("خطایی در بررسی عضویت رخ داد. لطفاً لحظاتی دیگر دوباره تلاش کنید.", show_alert=True)

async def rsgame_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """مدیریت دکمه‌های پنل اصلی بازی‌ها و بررسی مالکیت پنل."""
    query = update.callback_query
    
    # -- بخش جدید: بررسی مالکیت پنل --
    data = query.data.split('_')
    try:
        # آخرین بخش callback_data همیشه آیدی کاربر است
        target_user_id = int(data[-1]) 
    except (ValueError, IndexError):
        await query.answer("خطا: این دکمه منقضی شده است. لطفاً دوباره دستور را ارسال کنید.", show_alert=True)
        return

    clicker_user_id = query.from_user.id

    if clicker_user_id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
    # -- پایان بخش جدید --

    await query.answer()
    
    if await check_ban_status(update, context):
        return

    action_type = data[1]
    
    if len(data) > 2 and data[2] == "main":
        await rsgame_command(update, context)
        return
        
    # این بخش به تابع جداگانه منتقل شد، پس اینجا نیازی به آن نیست
    # if action_type == "close":
    #    await query.edit_message_text("پنل بسته شد.")
    #    return

    category = data[2]
    user_id = target_user_id
    text = "لطفا بازی مورد نظر خود را انتخاب کنید:"
    keyboard = []
    
    if category == "board":
        text = " دسته بندی بازی‌های کارتی و گروهی:\n\n(عضویت در کانال برای پیوستن به بازی الزامی است @RHINOSOUL_TM )"
        keyboard = [
            [InlineKeyboardButton(" حکم ۲ نفره ", callback_data=f"hokm_start_2p_{user_id}")],
            [InlineKeyboardButton(" حکم ۴ نفره ", callback_data=f"hokm_start_4p_{user_id}")],
            [InlineKeyboardButton("💠 دوز دو نفره ", callback_data=f"dooz_start_2p_{user_id}")],
            [InlineKeyboardButton("💠 دوز چهار نفره", callback_data=f"doz4p_start_{user_id}")],
            [InlineKeyboardButton(" چهار در یک ردیف ", callback_data=f"connect4_start_{user_id}")],
            [InlineKeyboardButton(" سنگ کاغذ قیچی ✂️", callback_data=f"rps_start_{user_id}")],
            [InlineKeyboardButton("🧠 بازی حافظه", callback_data=f"rsgame_cat_memory_{user_id}")],
            [InlineKeyboardButton(" بازگشت ", callback_data=f"rsgame_cat_main_{user_id}")]
        ]
    elif category == "memory":
        text = "🧠 لطفا سطح بازی حافظه را انتخاب کنید:"
        keyboard = [
            [
                InlineKeyboardButton("آسان (4x3)", callback_data=f"memory_start_4x3_{user_id}"),
                InlineKeyboardButton("متوسط (4x4)", callback_data=f"memory_start_4x4_{user_id}")
            ],
            [
                InlineKeyboardButton("سخت (6x4)", callback_data=f"memory_start_6x4_{user_id}"),
                InlineKeyboardButton("حرفه‌ای (6x6)", callback_data=f"memory_start_6x6_{user_id}")
            ],
            [InlineKeyboardButton(" بازگشت ", callback_data=f"rsgame_cat_main_{user_id}")]
        ]
    elif category == "typing":
        text = " دسته بندی بازی‌های تایپی و سرعتی (بدون اجبار عضویت):"
        keyboard = [
            [InlineKeyboardButton(" حدس کلمه ", callback_data=f"hads_kalame_start_{user_id}")],
            [InlineKeyboardButton(" تایپ سرعتی ", callback_data=f"type_start_{user_id}")],
            [InlineKeyboardButton(" حدس عدد (ویژه ادمین)", callback_data=f"hads_addad_start_{user_id}")],
            [InlineKeyboardButton(" بازگشت ", callback_data=f"rsgame_cat_main_{user_id}")]
        ]
    elif category == "single":
        text = "👤 لطفا بازی تک‌نفره مورد نظر خود را انتخاب کنید:"
        keyboard = [
            [InlineKeyboardButton("2️⃣0️⃣4️⃣8️⃣", callback_data=f"2048_start_{user_id}")],
            [InlineKeyboardButton("🔢 پازل کشویی", callback_data=f"spuzzle_start_{user_id}")],
            [InlineKeyboardButton("✨ بازی جفت‌ها", callback_data=f"samegame_start_{user_id}")],
            [InlineKeyboardButton(" بازگشت ", callback_data=f"rsgame_cat_main_{user_id}")]
        ]
    elif category == "anon":
        if not await is_group_admin(clicker_user_id, query.message.chat.id, context):
            await query.answer("این بخش فقط برای مدیران گروه در دسترس است.", show_alert=True)
            return
            
        text = " دسته بندی بازی‌های ناشناس (ویژه ادمین):"
        keyboard = [
            [InlineKeyboardButton(" اعتراف (متن پیش‌فرض) ", callback_data=f"eteraf_start_default_{user_id}")],
            [InlineKeyboardButton(" اعتراف (متن سفارشی) ", callback_data=f"eteraf_start_custom_{user_id}")],
            [InlineKeyboardButton(" قارچ (با نظارت گاد) ", callback_data=f"gharch_start_{user_id}")],
            [InlineKeyboardButton(" بازگشت ", callback_data=f"rsgame_cat_main_{user_id}")]
        ]
        
    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

# --------------------------- GAME: HOKM (بدون تغییر در منطق اصلی) ---------------------------
# توابع کمکی حکم (card_to_persian, create_deck, ...) همانند قبل باقی می‌مانند
# ... (کد بازی حکم در اینجا قرار می‌گیرد - بدون تغییر)

async def rsgame_close_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """پنل بازی را می‌بندد و مالکیت آن را چک می‌کند."""
    query = update.callback_query
    
    # --- بخش امنیتی جدید ---
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if query.from_user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
    # --- پایان بخش امنیتی ---

    await query.answer()
    try:
        await query.edit_message_text("پنل بسته شد.")
    except Exception:
        # اگر پیام خیلی قدیمی باشد یا مشکلی در ویرایش پیش بیاید، آن را حذف می‌کنیم
        try:
            await query.delete_message()
        except Exception:
            pass

# --- توابع کمکی حکم (بدون تغییر در منطق) ---

def create_deck():
    """یک دسته کارت مرتب شده ۵۲تایی ایجاد و آن را بُر می‌زند."""
    suits = ['S', 'H', 'D', 'C']  # Spades, Hearts, Diamonds, Clubs
    ranks = list(range(2, 15))  # 2-10, J(11), Q(12), K(13), A(14)
    deck = [f"{s}{r}" for s in suits for r in ranks]
    random.shuffle(deck)
    return deck

def card_to_persian(card):
    """کارت را به فرمت فارسی با ایموجی تبدیل می‌کند."""
    if not card: return "🃏"
    suits = {'S': '♠️', 'H': '♥️', 'D': '♦️', 'C': '♣️'}
    ranks = {11: 'J', 12: 'Q', 13: 'K', 14: 'A'}
    suit, rank = card[0], int(card[1:])
    rank_display = str(ranks.get(rank, rank))
    return f"{suits[suit]} {rank_display}"

def get_card_value(card, hokm_suit, trick_suit):
    """ارزش عددی یک کارت را برای مقایسه و تعیین برنده دست محاسبه می‌کند."""
    suit, rank = card[0], int(card[1:])
    value = rank
    if suit == hokm_suit:
        value += 200  # کارت‌های حکم بالاترین ارزش را دارند
    elif suit == trick_suit:
        value += 100  # کارت‌های خال زمین ارزش بیشتری از سایر خال‌ها دارند
    return value

async def render_hokm_board(game: dict, context: ContextTypes.DEFAULT_TYPE):
    """صفحه بازی (متن و دکمه‌ها) را بر اساس وضعیت فعلی بازی تولید می‌کند."""
    game_id = game['message_id']
    keyboard = []
    
    p_names = [p['name'] for p in game['players']]
    p_ids = [p['id'] for p in game['players']]
    
    table_cards_map = {pid: "➖" for pid in p_ids}
    for play in game.get('current_trick', []):
        table_cards_map[play['player_id']] = card_to_persian(play['card'])

    # بخش نمایش بازیکنان و کارت‌های روی میز
    if game['mode'] == '4p':
        team_a_text = f"🔴 تیم 1: {p_names[0]} و {p_names[2]}"
        team_b_text = f"🔵 تیم 2: {p_names[1]} و {p_names[3]}"
        
        board_layout = [
            [InlineKeyboardButton(team_a_text, callback_data=f"hokm_noop_{game_id}")],
            [InlineKeyboardButton(team_b_text, callback_data=f"hokm_noop_{game_id}")],
            [InlineKeyboardButton("بازیکن", callback_data=f"hokm_noop_{game_id}"), InlineKeyboardButton("کارت بازی شده", callback_data=f"hokm_noop_{game_id}")],
        ]
        for i in range(4):
            board_layout.append([
                InlineKeyboardButton(p_names[i], callback_data=f"hokm_noop_{game_id}"), 
                InlineKeyboardButton(table_cards_map[p_ids[i]], callback_data=f"hokm_noop_{game_id}")
            ])
        keyboard.extend(board_layout)
    else: # حالت دو نفره
        for i in range(2):
            keyboard.append([
                InlineKeyboardButton(p_names[i], callback_data=f"hokm_noop_{game_id}"), 
                InlineKeyboardButton(table_cards_map[p_ids[i]], callback_data=f"hokm_noop_{game_id}")
            ])

    # بخش نمایش وضعیت و امتیازات
    hokm_suit_fa = card_to_persian(f"{game['hokm_suit']}2")[0] if game.get('hokm_suit') else '❓'
    hakem_name = game.get('hakem_name', '...')
    
    if game['mode'] == '4p':
        trick_score_text = f"دست: 🔴 {game['trick_scores']['A']} - {game['trick_scores']['B']} 🔵"
        game_score_text = f"امتیاز کل: 🔴 {game['game_scores']['A']} - {game['game_scores']['B']} 🔵"
    else:
        trick_score_text = f"دست: {p_names[0]} {game['trick_scores'][p_ids[0]]} - {game['trick_scores'][p_ids[1]]} {p_names[1]}"
        game_score_text = f"امتیاز کل: {p_names[0]} {game['game_scores'][p_ids[0]]} - {game['game_scores'][p_ids[1]]} {p_names[1]}"

    keyboard.append([InlineKeyboardButton(f"حاکم: {hakem_name}", callback_data=f"hokm_noop_{game_id}"), InlineKeyboardButton(f"حکم: {hokm_suit_fa}", callback_data=f"hokm_noop_{game_id}")])
    keyboard.append([InlineKeyboardButton(trick_score_text, callback_data=f"hokm_noop_{game_id}")])
    keyboard.append([InlineKeyboardButton(game_score_text, callback_data=f"hokm_noop_{game_id}")])

    # بخش دکمه‌های کنترلی
    keyboard.append([InlineKeyboardButton("🃏 نمایش دست من (خصوصی)", callback_data=f"hokm_showhand_{game_id}")])

    if game['status'] == 'hakem_choosing' and game.get('turn_index') is not None and game['players'][game['turn_index']]['id'] == game.get('hakem_id'):
        suit_map = {'♠️': 'S', '♥️': 'H', '♦️': 'D', '♣️': 'C'}
        choose_buttons = [InlineKeyboardButton(emoji, callback_data=f"hokm_choose_{game_id}_{char}") for emoji, char in suit_map.items()]
        keyboard.append(choose_buttons)
    elif game['status'] == 'playing' and game.get('turn_index') is not None:
        current_player_id = game['players'][game['turn_index']]['id']
        if current_player_id in game['hands']:
            player_hand = sorted(game['hands'][current_player_id])
            card_buttons = [InlineKeyboardButton(str(i + 1), callback_data=f"hokm_play_{game_id}_{i}") for i in range(len(player_hand))]
            for i in range(0, len(card_buttons), 7):
                keyboard.append(card_buttons[i:i+7])
    
    return InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و اصلاح شده حکم ---

async def hokm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat_id
    
    # if await check_ban_status(update, context): return
    
    data = query.data.split('_')
    action = data[1]

    # --- بلوک ۱: شروع بازی ---
    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        mode = data[2]
        max_players = 4 if mode == '4p' else 2

        if chat_id not in active_games['hokm']:
            active_games['hokm'][chat_id] = {}
        
        sent_message = await query.message.reply_text(f"در حال ساخت بازی حکم {max_players} نفره...")
        game_id = sent_message.message_id
        
        game = {
            "status": "joining", 
            "mode": mode, 
            "players": [{'id': user.id, 'name': user.first_name}], 
            "message_id": game_id,
            "hands": {}, "deck": [], "hakem_id": None
        }
        active_games['hokm'][chat_id][game_id] = game
        
        keyboard = [[InlineKeyboardButton(f"پیوستن به بازی (1/{max_players})", callback_data=f"hokm_join_{game_id}")]]
        await sent_message.edit_text(
            f"بازی حکم {max_players} نفره توسط {user.mention_html()} ساخته شد! منتظر بازیکنان...\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)", 
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.HTML
        )
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    # --- بلوک ۲: مدیریت سایر اکشن‌های بازی (Join, Play, Choose ...) ---
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطا در پردازش درخواست.", show_alert=True)
        return

    if chat_id not in active_games['hokm'] or game_id not in active_games['hokm'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['hokm'][chat_id][game_id]

    # --- ساختار جدید با elif ---
    if action == "join":
        if not await check_join_for_alert(update, context):
            return
            
        if any(p['id'] == user.id for p in game['players']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
            
        max_players = 4 if game['mode'] == '4p' else 2
        if len(game['players']) >= max_players:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            await query.answer()
        game['players'].append({'id': user.id, 'name': user.first_name})
        num_players = len(game['players'])

        if num_players < max_players:
            keyboard = [[InlineKeyboardButton(f"پیوستن به بازی ({num_players}/{max_players})", callback_data=f"hokm_join_{game_id}")]]
            player_names = "، ".join([p['name'] for p in game['players']])
            await query.edit_message_text(f"بازی حکم منتظر بازیکنان...\n\nبازیکنان فعلی: {player_names}\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)", reply_markup=InlineKeyboardMarkup(keyboard))
        else:
            p_ids = [p['id'] for p in game['players']]
            game.update({
                "status": "dealing_first_5", "deck": create_deck(), "hands": {pid: [] for pid in p_ids},
                "hakem_id": None, "hakem_name": None, "turn_index": 0, "hokm_suit": None, "current_trick": [],
                "trick_scores": {'A': 0, 'B': 0} if game['mode'] == '4p' else {pid: 0 for pid in p_ids},
                "game_scores": game.get('game_scores', {'A': 0, 'B': 0} if game['mode'] == '4p' else {pid: 0 for pid in p_ids})
            })

            for _ in range(5):
                for p in game['players']: game['hands'][p['id']].append(game['deck'].pop(0))
            
            hakem_p = next((p for p in game['players'] if 'S14' in game['hands'][p['id']]), game['players'][0])
            game.update({"hakem_id": hakem_p['id'], "hakem_name": hakem_p['name'], "status": 'hakem_choosing'})
            game['turn_index'] = next(i for i, p in enumerate(game['players']) if p['id'] == hakem_p['id'])
            
            reply_markup = await render_hokm_board(game, context)
            await query.edit_message_text(f"بازیکنان کامل شدند!\nحاکم: {game['hakem_name']}\n\nلطفا حکم را انتخاب کنید.", reply_markup=reply_markup)

    elif action == "choose":
        if user.id != game.get('hakem_id'):
            await query.answer("شما حاکم نیستید!", show_alert=True)
            return
        if game['status'] != 'hakem_choosing':
            await query.answer("الان زمان انتخاب حکم نیست!", show_alert=True)
            return
            
        game['hokm_suit'] = data[3]
        
        for p in game['players']:
            while len(game['hands'][p['id']]) < 13: 
                if not game['deck']: break
                game['hands'][p['id']].append(game['deck'].pop(0))
        
        game['status'] = 'playing'
        game['turn_index'] = next(i for i, p in enumerate(game['players']) if p['id'] == game['hakem_id'])
        turn_player_name = game['players'][game['turn_index']]['name']
        
        reply_markup = await render_hokm_board(game, context)
        await query.edit_message_text(f"بازی شروع شد! حکم: {card_to_persian(game['hokm_suit']+'2')[0]}\n\nنوبت {turn_player_name} است.", reply_markup=reply_markup)

    elif action == "showhand":
        if not any(p['id'] == user.id for p in game['players']):
            await query.answer("شما بازیکن این مسابقه نیستید!", show_alert=True)
            return
        hand = sorted(game['hands'].get(user.id, []))
        hand_str = "\n".join([f"{NUMBER_EMOJIS[i]} {card_to_persian(c)}" for i, c in enumerate(hand)]) or "شما کارتی در دست ندارید."
        await query.answer(f"دست شما:\n{hand_str}", show_alert=True)

    elif action == "play":
        if game['status'] != 'playing' or user.id != game['players'][game['turn_index']]['id']:
            await query.answer("نوبت شما نیست!", show_alert=True)
            return
        
        card_index = int(data[3])
        hand = sorted(game['hands'][user.id]) 
        if not (0 <= card_index < len(hand)):
            await query.answer("شماره کارت نامعتبر است.", show_alert=True)
            return
        
        card_played = hand[card_index]
        if game['current_trick']:
            trick_suit = game['current_trick'][0]['card'][0]
            if any(c.startswith(trick_suit) for c in hand) and not card_played.startswith(trick_suit):
                await query.answer(f"شما باید از خال زمین ({card_to_persian(trick_suit+'2')[0]}) بازی کنید!", show_alert=True)
                return

        game['hands'][user.id].remove(card_played)
        game['current_trick'].append({'player_id': user.id, 'card': card_played})

        num_players = len(game['players'])
        if len(game['current_trick']) < num_players:
            game['turn_index'] = (game['turn_index'] + 1) % num_players
            turn_player_name = game['players'][game['turn_index']]['name']
            reply_markup = await render_hokm_board(game, context)
            await query.edit_message_text(f"حکم: {card_to_persian(game['hokm_suit']+'2')[0]}\n\nنوبت {turn_player_name} است.", reply_markup=reply_markup)
            return

        # --- دست تکمیل شده، برنده را مشخص کن ---
        trick_suit = game['current_trick'][0]['card'][0]
        winner_play = max(game['current_trick'], key=lambda p: get_card_value(p['card'], game['hokm_suit'], trick_suit))
        winner_id = winner_play['player_id']
        
        if game['mode'] == '4p':
            winner_team = 'A' if winner_id in [game['players'][0]['id'], game['players'][2]['id']] else 'B'
            game['trick_scores'][winner_team] += 1
            round_over = game['trick_scores']['A'] == 7 or game['trick_scores']['B'] == 7
        else:
            game['trick_scores'][winner_id] += 1
            round_over = any(score == 7 for score in game['trick_scores'].values())

        game['turn_index'] = next(i for i, p in enumerate(game['players']) if p['id'] == winner_id)
        
        # نمایش موقت نتیجه دست
        winner_name = next(p['name'] for p in game['players'] if p['id'] == winner_id)
        temp_game_state = game.copy()
        temp_reply_markup = await render_hokm_board(temp_game_state, context)
        await query.edit_message_text(f"برنده این دست: {winner_name}\n\nصبر کنید...", reply_markup=temp_reply_markup)
        
        await asyncio.sleep(2.5)

        game['current_trick'] = [] # پاک کردن میز

        if not round_over:
            turn_player_name = game['players'][game['turn_index']]['name']
            reply_markup = await render_hokm_board(game, context)
            await query.edit_message_text(f"حکم: {card_to_persian(game['hokm_suit']+'2')[0]}\n\nنوبت {turn_player_name} است.", reply_markup=reply_markup)
        else:
            # --- دور تمام شده، امتیاز را ثبت کن ---
            if game['mode'] == '4p':
                winning_team_name = 'A' if game['trick_scores']['A'] == 7 else 'B'
                game['game_scores'][winning_team_name] += 1
                winner_display_name = f"تیم {winning_team_name}"
                game_over = game['game_scores'][winning_team_name] == 7
            else:
                round_winner_id = next(pid for pid, score in game['trick_scores'].items() if score == 7)
                winner_display_name = next(p['name'] for p in game['players'] if p['id'] == round_winner_id)
                game['game_scores'][round_winner_id] += 1
                game_over = any(score == 7 for score in game['game_scores'].values())

            if game_over:
                await query.edit_message_text(f"🏆 **بازی تمام شد!** 🏆\n\nبرنده نهایی: **{winner_display_name}**", parse_mode=ParseMode.MARKDOWN)
                del active_games['hokm'][chat_id][game_id]
                return
            
            # --- شروع دور جدید ---
            current_hakem_index = next(i for i, p in enumerate(game['players']) if p['id'] == game['hakem_id'])
            if game['mode'] == '4p':
                hakem_team = 'A' if current_hakem_index in [0, 2] else 'B'
                next_hakem_index = current_hakem_index if winning_team_name == hakem_team else (current_hakem_index + 1) % 4
            else:
                round_winner_id = next(pid for pid, score in game['trick_scores'].items() if score == 7)
                next_hakem_index = current_hakem_index if round_winner_id == game['hakem_id'] else (current_hakem_index + 1) % 2
            
            p_ids = [p['id'] for p in game['players']]
            game.update({ 
                "status": "dealing_first_5", "deck": create_deck(), 
                "hands": {pid: [] for pid in p_ids},
                "trick_scores": {'A': 0, 'B': 0} if game['mode'] == '4p' else {pid: 0 for pid in p_ids} 
            })
            for _ in range(5):
                for p in game['players']: game['hands'][p['id']].append(game['deck'].pop(0))
            
            game['hakem_id'] = game['players'][next_hakem_index]['id']
            game['hakem_name'] = game['players'][next_hakem_index]['name']
            game['status'] = 'hakem_choosing'
            game['turn_index'] = next_hakem_index

            reply_markup = await render_hokm_board(game, context)
            await query.edit_message_text(f"این دست تمام شد! برنده: {winner_display_name}\n\n-- دور جدید --\nحاکم جدید: {game['hakem_name']}\nمنتظر انتخاب حکم...", reply_markup=reply_markup)

    elif action == "noop":
        # این دکمه‌ها کاری انجام نمی‌دهند، پس فقط answer می‌دهیم
        pass
# --------------------------- GAME: 2048 (جدید) ---------------------------
# --- توابع کمکی 2048 (بدون تغییر در منطق) ---

def new_2048_board():
    """یک صفحه خالی ۴x۴ برای بازی 2048 ایجاد می‌کند."""
    return [[0] * 4 for _ in range(4)]

def add_new_2048_tile(board):
    """یک مهره ۲ یا ۴ به صورت تصادفی به یک خانه خالی اضافه می‌کند."""
    empty_cells = [(r, c) for r in range(4) for c in range(4) if board[r][c] == 0]
    if not empty_cells:
        return board
    r, c = random.choice(empty_cells)
    board[r][c] = 2 if random.random() < 0.9 else 4  # 90% شانس برای ۲
    return board

def can_move_2048(board):
    """بررسی می‌کند آیا حرکتی در صفحه امکان‌پذیر است یا خیر."""
    for r in range(4):
        for c in range(4):
            if board[r][c] == 0:
                return True  # خانه خالی وجود دارد
            # چک کردن همسایه‌های سمت راست و پایین
            if c < 3 and board[r][c] == board[r][c+1]:
                return True
            if r < 3 and board[r][c] == board[r+1][c]:
                return True
    return False

def transform_2048_board(board, direction):
    """صفحه را بر اساس جهت حرکت می‌چرخاند تا منطق حرکت به چپ برای همه جهات قابل استفاده باشد."""
    if direction == 'left':
        return board
    if direction == 'right':
        return [row[::-1] for row in board]
    if direction == 'up':
        return [list(col) for col in zip(*board)]  # Transpose
    if direction == 'down':
        new_board = [list(col) for col in zip(*board)]  # Transpose
        return [row[::-1] for row in new_board]

def reverse_transform_2048_board(board, direction):
    """صفحه چرخانده شده را به حالت اولیه برمی‌گرداند."""
    if direction == 'left':
        return board
    if direction == 'right':
        return [row[::-1] for row in board]
    if direction == 'up':
        return [list(col) for col in zip(*board)]  # Transpose
    if direction == 'down':
        board = [row[::-1] for row in board]
        return [list(col) for col in zip(*board)]  # Transpose

def move_2048_left(board):
    """منطق اصلی حرکت و ادغام مهره‌ها به سمت چپ."""
    new_board = []
    score_increment = 0
    moved = False
    for row in board:
        compressed_row = [num for num in row if num != 0]
        new_row = []
        i = 0
        while i < len(compressed_row):
            if i + 1 < len(compressed_row) and compressed_row[i] == compressed_row[i+1]:
                new_value = compressed_row[i] * 2
                new_row.append(new_value)
                score_increment += new_value
                i += 2
            else:
                new_row.append(compressed_row[i])
                i += 1
        new_row.extend([0] * (4 - len(new_row)))
        new_board.append(new_row)
    
    if board != new_board:
        moved = True
        
    return new_board, score_increment, moved

async def render_2048_board(game):
    """صفحه بازی 2048 را برای نمایش به کاربر رندر می‌کند."""
    game_id = game['game_id']
    board = game['board']
    score = game['score']
    
    tile_map = {0: " ", 2: "2️⃣", 4: "4️⃣", 8: "8️⃣", 16: "1️⃣6️⃣", 32: "3️⃣2️⃣", 64: "6️⃣4️⃣", 128: "1️⃣2️⃣8️⃣", 256: "2️⃣5️⃣6️⃣", 512: "5️⃣1️⃣2️⃣", 1024: "🔟2️⃣4️⃣", 2048: "🏆"}
    
    text = f"🔢 **بازی 2048**\n\nامتیاز: **{score}**"
    
    keyboard = []
    for r in range(4):
        row_buttons = [InlineKeyboardButton(tile_map.get(cell, str(cell)), callback_data=f"2048_noop_{game_id}") for cell in board[r]]
        keyboard.append(row_buttons)
        
    keyboard.extend([
        [
            InlineKeyboardButton(" ", callback_data=f"2048_noop_{game_id}"),
            InlineKeyboardButton("⬆️", callback_data=f"2048_move_{game_id}_up"),
            InlineKeyboardButton(" ", callback_data=f"2048_noop_{game_id}"),
        ],
        [
            InlineKeyboardButton("⬅️", callback_data=f"2048_move_{game_id}_left"),
            InlineKeyboardButton(" ", callback_data=f"2048_noop_{game_id}"),
            InlineKeyboardButton("➡️", callback_data=f"2048_move_{game_id}_right"),
        ],
        [
            InlineKeyboardButton(" ", callback_data=f"2048_noop_{game_id}"),
            InlineKeyboardButton("⬇️", callback_data=f"2048_move_{game_id}_down"),
            InlineKeyboardButton(" ", callback_data=f"2048_noop_{game_id}"),
        ],
        [InlineKeyboardButton("✖️ بستن بازی", callback_data=f"2048_close_{game_id}")]
    ])
    
    return text, InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و اصلاح شده 2048 ---

async def game_2048_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user = query.from_user
    chat_id = query.message.chat.id

    data = query.data.split('_')
    action = data[1]

    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['2048']:
            active_games['2048'][chat_id] = {}
        
        if any(g['player_id'] == user.id for g in active_games['2048'].get(chat_id, {}).values()):
            await query.answer("شما از قبل یک بازی 2048 فعال دارید.", show_alert=True)
            return

        sent_message = await query.message.reply_text("در حال ساخت بازی 2048...")
        game_id = sent_message.message_id
        
        initial_board = new_2048_board()
        add_new_2048_tile(initial_board)
        add_new_2048_tile(initial_board)
        
        game = {
            "game_id": game_id,
            "player_id": user.id,
            "board": initial_board,
            "score": 0,
            "is_busy": False
        }
        active_games['2048'][chat_id][game_id] = game
        
        text, reply_markup = await render_2048_board(game)
        await sent_message.edit_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطا در پردازش درخواست.", show_alert=True)
        return

    if chat_id not in active_games['2048'] or game_id not in active_games['2048'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['2048'][chat_id][game_id]
    
    if user.id != game['player_id']:
        await query.answer("این بازی برای شما نیست!", show_alert=True)
        return

    if game.get('is_busy', False):
        return

    if action == "move":
        game['is_busy'] = True
        try:
            direction = data[3]
            
            transformed = transform_2048_board(game['board'], direction)
            moved_board, score_inc, moved = move_2048_left(transformed)
            final_board = reverse_transform_2048_board(moved_board, direction)

            if moved:
                game['board'] = add_new_2048_tile(final_board)
                game['score'] += score_inc
            else:
                await query.answer("حرکت غیرمجاز!")
                return

            text, reply_markup = await render_2048_board(game)
            
            game_over = False
            if any(2048 in row for row in game['board']):
                text += f"\n\n🏆 **تبریک!** شما برنده شدید! 🏆"
                game_over = True
            elif not can_move_2048(game['board']):
                text += f"\n\n☠️ **بازی تمام شد!** شما باختید."
                game_over = True

            if game_over:
                await query.edit_message_text(text, reply_markup=None, parse_mode=ParseMode.MARKDOWN)
                del active_games['2048'][chat_id][game_id]
            else:
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        finally:
            if chat_id in active_games['2048'] and game_id in active_games['2048'][chat_id]:
                active_games['2048'][chat_id][game_id]['is_busy'] = False

    elif action == "close":
        await query.edit_message_text("بازی 2048 بسته شد.")
        del active_games['2048'][chat_id][game_id]

    elif action == "noop":
        pass

# --------------------------- GAME: GUESS THE NUMBER (ConversationHandler - بدون تغییر) ---------------------------
async def hads_addad_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = query.from_user
    context.chat_data['starter_admin_id'] = query.from_user.id
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
        await query.answer()
    
    if await check_ban_status(update, context): return ConversationHandler.END
    
    # الرت برای کاربر عادی
    if not await is_group_admin(query.from_user.id, query.message.chat.id, context):
        await query.answer("❌ این بازی فقط توسط مدیران گروه قابل اجراست.", show_alert=True)
        return ConversationHandler.END
        
    if query.message.chat.id in active_games['guess_number']:
        await query.answer("یک بازی حدس عدد در این گروه فعال است.", show_alert=True)
        return ConversationHandler.END
        
    await query.edit_message_text("بازه بازی را مشخص کنید. (مثال: `1-1000`)\nبرای لغو /cancel را ارسال کنید.", parse_mode=ParseMode.MARKDOWN)
    return SELECTING_RANGE

async def receive_range(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    starter_admin_id = context.chat_data.get('starter_admin_id')
    current_user_id = update.effective_user.id

    # اگر کاربری که پیام داده، همان ادمینی نیست که بازی را شروع کرده، پیام را نادیده بگیر
    if current_user_id != starter_admin_id:
        return SELECTING_RANGE # در همان وضعیت باقی بمان و هیچ کاری نکن
    # --- پایان بخش جدید ---
    chat = update.effective_chat
    try:
        min_str, max_str = convert_persian_to_english_numbers(update.message.text).split('-')
        min_range, max_range = int(min_str.strip()), int(max_str.strip())
        if min_range >= max_range: raise ValueError
    except:
        await update.message.reply_text("فرمت اشتباه است. لطفا به این صورت وارد کنید: `عدد کوچک-عدد بزرگ`", parse_mode=ParseMode.MARKDOWN)
        return SELECTING_RANGE
    secret_number = random.randint(min_range, max_range)
    active_games['guess_number'][chat.id] = {"number": secret_number}
    await update.message.reply_text(f"🎲 **بازی حدس عدد شروع شد!** 🎲\n\nیک عدد بین **{min_range}** و **{max_range}** انتخاب شده.", parse_mode=ParseMode.MARKDOWN)
    return GUESSING

async def handle_guess_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    chat_id = update.effective_chat.id
    if chat_id not in active_games['guess_number']: return ConversationHandler.END
    guess = int(convert_persian_to_english_numbers(update.message.text))
    secret_number = active_games['guess_number'][chat_id]['number']
    user = update.effective_user
    if guess < secret_number: await update.message.reply_text("بالاتر ⬆️")
    elif guess > secret_number: await update.message.reply_text("پایین‌تر ⬇️")
    else:
        await update.message.reply_text(f"🎉 **تبریک!** {user.mention_html()} برنده شد! 🎉\n\nعدد صحیح **{secret_number}** بود.", parse_mode=ParseMode.HTML)
        del active_games['guess_number'][chat_id]
        return ConversationHandler.END
    return GUESSING

async def cancel_game_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.effective_chat.id in active_games['guess_number']: del active_games['guess_number'][update.effective_chat.id]
    await update.message.reply_text('بازی حدس عدد لغو شد.')
    # بازگشت به پنل اصلی
    await rsgame_command(update, context)
    return ConversationHandler.END

# --------------------------- GAME: DOOZ (TIC-TAC-TOE) - ##### بازنویسی کامل ##### ---------------------------
async def dooz_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat_id

    # if await check_ban_status(update, context): return

    data = query.data.split('_')
    action = data[1]

    # --- بلوک ۱: شروع بازی ---
    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['dooz']:
            active_games['dooz'][chat_id] = {}

        # ایجاد پیام جدید برای بازی
        sent_message = await query.message.reply_text("در حال ساخت بازی دوز...")
        game_id = sent_message.message_id
        
        game = {
            "status": "joining",
            "players_info": [{'id': user.id, 'name': user.first_name, 'symbol': '❌'}],
            "board": [[" "]*3 for _ in range(3)],
            "turn": None
        }
        active_games['dooz'][chat_id][game_id] = game
        
        keyboard = [[InlineKeyboardButton("پیوستن به بازی (1/2)", callback_data=f"dooz_join_{game_id}")]]
        await sent_message.edit_text(
            f"بازی دوز توسط {user.mention_html()} ساخته شد! منتظر حریف...\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)", 
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.HTML
        )
        
        # حذف پنل اصلی بازی‌ها
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    # --- بلوک ۲: مدیریت سایر اکشن‌های بازی ---
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطا در پردازش درخواست.", show_alert=True)
        return

    if chat_id not in active_games['dooz'] or game_id not in active_games['dooz'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['dooz'][chat_id][game_id]

    # --- ساختار جدید با elif ---
    if action == "join":
        if not await check_join_for_alert(update, context): return

        if any(p['id'] == user.id for p in game['players_info']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
        
        if len(game['players_info']) >= 2:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            await query.answer()
        game['players_info'].append({'id': user.id, 'name': user.first_name, 'symbol': '⭕️'})
        game['status'] = 'playing'
        game['turn'] = game['players_info'][0]['id'] # نوبت با بازیکن اول

        p1 = game['players_info'][0]
        p2 = game['players_info'][1]

        text = f"بازی شروع شد!\n{p1['name']} ({p1['symbol']}) ⚔️ {p2['name']} ({p2['symbol']})\n\nنوبت {p1['name']} است."
        
        # ساخت کیبورد اولیه بازی
        keyboard = [
            [InlineKeyboardButton(" ", callback_data=f"dooz_move_{game_id}_{r*3+c}") for c in range(3)] 
            for r in range(3)
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)

    elif action == "move":
        if game['status'] != 'playing':
            await query.answer("بازی تمام شده است.", show_alert=True)
            return
            
        if user.id not in [p['id'] for p in game['players_info']]:
            await query.answer("شما بازیکن این مسابقه نیستید!", show_alert=True)
            return
            
        if user.id != game['turn']:
            await query.answer("نوبت شما نیست!", show_alert=True)
            return

        try:
            cell_index = int(data[3])
            row, col = divmod(cell_index, 3)
        except (ValueError, IndexError):
            return # در صورت callback_data اشتباه، کاری انجام نده

        if game['board'][row][col] != " ":
            await query.answer("این خانه پر شده است!", show_alert=True)
            return
        
        current_player = next(p for p in game['players_info'] if p['id'] == user.id)
        symbol = current_player['symbol']
        game['board'][row][col] = symbol
        
        # بررسی وضعیت برد
        b = game['board']
        win = any(all(c==symbol for c in r) for r in b) or \
              any(all(b[r][c]==symbol for r in range(3)) for c in range(3)) or \
              all(b[i][i]==symbol for i in range(3)) or \
              all(b[i][2-i]==symbol for i in range(3))
        
        is_draw = all(c!=" " for r in b for c in r) and not win
        
        # ساخت کیبورد جدید بر اساس وضعیت فعلی صفحه
        board_rows = [
            [InlineKeyboardButton(b[r][c], callback_data=f"dooz_move_{game_id}_{r*3+c}") for c in range(3)]
            for r in range(3)
        ]
        
        # اگر بازی تمام شد
        if win or is_draw:
            text = f"بازی مساوی شد! 🤝" if is_draw else f"بازی تمام شد! برنده: {current_player['name']} 🏆"
            game['status'] = 'finished' # وضعیت بازی را تغییر می‌دهیم
            
            # **نکته کلیدی:** کیبورد نهایی را با دکمه‌های غیرفعال می‌سازیم
            final_keyboard_rows = [
                [InlineKeyboardButton(b[r][c], callback_data=f"dooz_noop_{game_id}") for c in range(3)]
                for r in range(3)
            ]
            
            await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(final_keyboard_rows), parse_mode=ParseMode.HTML)
            # بازی را از لیست بازی‌های فعال حذف می‌کنیم
            del active_games['dooz'][chat_id][game_id]
        
        # اگر بازی ادامه دارد
        else:
            next_player = next(p for p in game['players_info'] if p['id'] != user.id)
            game['turn'] = next_player['id']
            text = f"نوبت {next_player['name']} ({next_player['symbol']}) است."
            await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(board_rows), parse_mode=ParseMode.HTML)

    elif action == "noop":
        # برای دکمه‌های غیرفعال در انتهای بازی
        await query.answer("این بازی تمام شده است.", show_alert=True)

# --------------------------- GAME: CONNECT FOUR (جدید) --------------------------
# --- توابع کمکی Connect Four (منطق اصلی بدون تغییر) ---

def check_connect4_winner(board, symbol):
    """بررسی می‌کند که آیا بازیکن با مهره 'symbol' برنده شده است یا خیر."""
    ROWS, COLS = 6, 7
    # بررسی افقی
    for r in range(ROWS):
        for c in range(COLS - 3):
            if all(board[r][c+i] == symbol for i in range(4)):
                return True
    # بررسی عمودی
    for r in range(ROWS - 3):
        for c in range(COLS):
            if all(board[r+i][c] == symbol for i in range(4)):
                return True
    # بررسی مورب (پایین به بالا)
    for r in range(3, ROWS):
        for c in range(COLS - 3):
            if all(board[r-i][c+i] == symbol for i in range(4)):
                return True
    # بررسی مورب (بالا به پایین)
    for r in range(ROWS - 3):
        for c in range(COLS - 3):
            if all(board[r+i][c+i] == symbol for i in range(4)):
                return True
    return False

# --- تابع رندر بهینه‌سازی شده ---

def render_connect4_board(game: dict, is_finished: bool = False):
    """صفحه بازی را به همراه متن و دکمه‌ها تولید می‌کند."""
    game_id = game['game_id']
    board = game['board']
    
    # تعیین متن پیام بر اساس وضعیت بازی
    if is_finished:
        p1 = game['players_info'][0]
        p2 = game['players_info'][1]
        text = f"بازی تمام شد!\n{p1['name']} ({p1['symbol']}) ⚔️ {p2['name']} ({p2['symbol']})"
    else:
        p1 = game['players_info'][0]
        p2 = game['players_info'][1]
        turn_player_id = game.get('turn')
        turn_player = next(p for p in game['players_info'] if p['id'] == turn_player_id)
        text = f"بازی چهار در یک ردیف\n{p1['name']} ({p1['symbol']}) ⚔️ {p2['name']} ({p2['symbol']})\n\nنوبت {turn_player['name']} است."

    # ساخت کیبورد
    keyboard = []
    for r in range(len(board)):
        row_buttons = []
        for c in range(len(board[0])):
            # اگر بازی تمام شده باشد، دکمه‌ها غیرفعال می‌شوند
            callback_action = "noop" if is_finished else "move"
            row_buttons.append(InlineKeyboardButton(board[r][c], callback_data=f"connect4_{callback_action}_{game_id}_{c}"))
        keyboard.append(row_buttons)
    
    return text, InlineKeyboardMarkup(keyboard)


# --- تابع اصلی و اصلاح شده Connect Four ---

async def connect4_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id

    # if await check_ban_status(update, context): return
    
    data = query.data.split('_')
    action = data[1]

    # --- بلوک ۱: شروع بازی ---
    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['connect4']:
            active_games['connect4'][chat_id] = {}

        sent_message = await query.message.reply_text("در حال ساخت بازی چهار در یک ردیف...")
        game_id = sent_message.message_id
        
        game = {
            "game_id": game_id,
            "status": "joining",
            "players_info": [{'id': user.id, 'name': user.first_name, 'symbol': '🔴'}],
            "board": [['⚪️']*7 for _ in range(6)],
            "turn": None
        }
        active_games['connect4'][chat_id][game_id] = game
        
        text = f"بازی چهار در یک ردیف توسط {user.mention_html()} ساخته شد! منتظر حریف...\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)"
        keyboard = [[InlineKeyboardButton("پیوستن به بازی (1/2)", callback_data=f"connect4_join_{game_id}")]]
        await sent_message.edit_text(
            text, 
            reply_markup=InlineKeyboardMarkup(keyboard), 
            parse_mode=ParseMode.HTML
        )
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    # --- بلوک ۲: مدیریت سایر اکشن‌های بازی ---
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطا در پردازش درخواست.", show_alert=True)
        return

    if chat_id not in active_games['connect4'] or game_id not in active_games['connect4'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['connect4'][chat_id][game_id]

    if action == "join":
        if not await check_join_for_alert(update, context): return

        if any(p['id'] == user.id for p in game['players_info']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
        
        if len(game['players_info']) >= 2:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            await query.answer()
        game['players_info'].append({'id': user.id, 'name': user.first_name, 'symbol': '🟡'})
        game['status'] = 'playing'
        game['turn'] = game['players_info'][0]['id']

        text, reply_markup = render_connect4_board(game)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    elif action == "move":
        if game.get('status') != 'playing':
            await query.answer("بازی تمام شده است.", show_alert=True)
            return

        if user.id not in [p['id'] for p in game['players_info']]:
            await query.answer("شما بازیکن این مسابقه نیستید!", show_alert=True)
            return
        
        if user.id != game.get('turn'):
            await query.answer("نوبت شما نیست!", show_alert=True)
            return

        col_index = int(data[3])
        
        # پیدا کردن پایین‌ترین خانه خالی در ستون
        row_index = -1
        for r in range(5, -1, -1):
            if game['board'][r][col_index] == '⚪️':
                row_index = r
                break
        
        if row_index == -1:
            await query.answer("این ستون پر است!", show_alert=True)
            return
            
        current_player = next(p for p in game['players_info'] if p['id'] == user.id)
        symbol = current_player['symbol']
        game['board'][row_index][col_index] = symbol

        # بررسی برنده یا مساوی
        is_winner = check_connect4_winner(game['board'], symbol)
        is_draw = all(cell != '⚪️' for row in game['board'] for cell in row) and not is_winner

        if is_winner or is_draw:
            game['status'] = 'finished'
            text, reply_markup = render_connect4_board(game, is_finished=True)
            
            if is_winner:
                text += f"\n\n🏆 برنده: {current_player['name']}"
            else:
                text += f"\n\n🤝 بازی مساوی شد!"

            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
            del active_games['connect4'][chat_id][game_id]
        else:
            # تغییر نوبت
            next_player = next(p for p in game['players_info'] if p['id'] != user.id)
            game['turn'] = next_player['id']
            
            text, reply_markup = render_connect4_board(game)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    elif action == "noop":
        await query.answer("این بازی تمام شده است.", show_alert=True)

# --------------------------- GAME: ROCK, PAPER, SCISSORS (جدید) ---------------------------

async def rps_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id

    # if await check_ban_status(update, context): return
    
    data = query.data.split('_')
    action = data[1]

    # --- بلوک ۱: شروع بازی ---
    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['rps']:
            active_games['rps'][chat_id] = {}
            
        sent_message = await query.message.reply_text("در حال ساخت بازی سنگ، کاغذ، قیچی...")
        game_id = sent_message.message_id
        game = {
            "game_id": game_id, 
            "status": "joining",
            "players_info": [{'id': user.id, 'name': user.first_name}],
            "choices": {}
        }
        active_games['rps'][chat_id][game_id] = game
        
        text = f"بازی سنگ، کاغذ، قیچی توسط {user.mention_html()} ساخته شد! منتظر حریف...\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)"
        keyboard = [[InlineKeyboardButton("پیوستن به بازی (1/2)", callback_data=f"rps_join_{game_id}")]]
        await sent_message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    # --- بلوک ۲: مدیریت سایر اکشن‌های بازی ---
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطا در پردازش درخواست.", show_alert=True)
        return

    if chat_id not in active_games['rps'] or game_id not in active_games['rps'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['rps'][chat_id][game_id]

    if action == "join":
        if not await check_join_for_alert(update, context): return
        
        if any(p['id'] == user.id for p in game['players_info']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
            
        if len(game['players_info']) >= 2:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            await query.answer()
        game['players_info'].append({'id': user.id, 'name': user.first_name})
        game['status'] = 'playing'
        
        p1_name = game['players_info'][0]['name']
        p2_name = game['players_info'][1]['name']
        
        text = f"بازی شروع شد!\n\n{p1_name} ⚔️ {p2_name}\n\nلطفا انتخاب خود را انجام دهید:"
        keyboard = [[
            InlineKeyboardButton("🪨 سنگ", callback_data=f"rps_choose_{game_id}_rock"),
            InlineKeyboardButton("📄 کاغذ", callback_data=f"rps_choose_{game_id}_paper"),
            InlineKeyboardButton("✂️ قیچی", callback_data=f"rps_choose_{game_id}_scissors")
        ]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

    elif action == "choose":
        if game.get('status') != 'playing':
            await query.answer("بازی هنوز شروع نشده یا تمام شده است.", show_alert=True)
            return

        if user.id not in [p['id'] for p in game['players_info']]:
            await query.answer("شما بازیکن این مسابقه نیستید!", show_alert=True)
            return
            
        if user.id in game['choices']:
            await query.answer("شما قبلاً انتخاب خود را ثبت کرده‌اید!", show_alert=True)
            return
        
        try:
            choice = data[3]
            game['choices'][user.id] = choice
            await query.answer(f"انتخاب شما ثبت شد.")
        except IndexError:
            return # callback_data ناقص است

        p1 = game['players_info'][0]
        p2 = game['players_info'][1]
        
        # اگر هنوز منتظر انتخاب بازیکن دوم هستیم
        if len(game['choices']) < 2:
            p1_status = "✅ (انتخاب کرد)" if p1['id'] in game['choices'] else "🤔 (منتظر...)"
            p2_status = "✅ (انتخاب کرد)" if p2['id'] in game['choices'] else "🤔 (منتظر...)"
            
            text = f"بازی در جریان است...\n\n{p1['name']}: {p1_status}\n{p2['name']}: {p2_status}\n\nمنتظر انتخاب حریف..."
            
            keyboard = [[
                InlineKeyboardButton("🪨 سنگ", callback_data=f"rps_choose_{game_id}_rock"),
                InlineKeyboardButton("📄 کاغذ", callback_data=f"rps_choose_{game_id}_paper"),
                InlineKeyboardButton("✂️ قیچی", callback_data=f"rps_choose_{game_id}_scissors")
            ]]
            await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

        # اگر هر دو بازیکن انتخاب کرده باشند
        else:
            p1_choice = game['choices'][p1['id']]
            p2_choice = game['choices'][p2['id']]
            symbols = {'rock': '🪨', 'paper': '📄', 'scissors': '✂️'}
            
            winner = None
            rules = {'rock': 'scissors', 'paper': 'rock', 'scissors': 'paper'}

            if rules[p1_choice] == p2_choice:
                winner = p1
            elif rules[p2_choice] == p1_choice:
                winner = p2
            
            # ساخت پیام نهایی در یک مرحله
            final_text = (
                f"نتایج بازی:\n\n"
                f"{p1['name']}: {symbols[p1_choice]}\n"
                f"{p2['name']}: {symbols[p2_choice]}\n\n"
            )
            
            if winner:
                final_text += f"🏆 **برنده: {winner['name']}**"
            else:
                final_text += "🤝 **بازی مساوی شد!**"

            # ویرایش پیام نهایی و حذف دکمه‌ها
            await query.edit_message_text(final_text, reply_markup=None, parse_mode=ParseMode.MARKDOWN)
            del active_games['rps'][chat_id][game_id]

# --------------------------- GAME: MEMORY GAME (جدید) ---------------------------
# --- لیست ایموجی‌ها (بدون تغییر) ---
MEMORY_EMOJIS = [
    "🍎", "🍓", "🍉", "🍕", "🍔", "🎂", "🍦", "🍩", "🍿", "🌸", "🌻", "🍁", "🍀", "🍄", "🌈", "⭐", "🔥", "🌊",
    "⚽", "🏀", "🎳", "🎸", "🎮", "🎯", "🎨", "🚀", "🚁", "🎁", "🎈", "💎", "👑", "❤️", "🧡", "💙", "💚", "💜"
]

# --- توابع کمکی (منطق بدون تغییر) ---
def generate_memory_board(rows, cols):
    """یک لیست درهم‌ریخته از جفت ایموجی‌ها برای صفحه بازی تولید می‌کند."""
    num_pairs = (rows * cols) // 2
    emojis_for_game = random.sample(MEMORY_EMOJIS, num_pairs)
    card_deck = emojis_for_game * 2
    random.shuffle(card_deck)
    
    board = []
    for i in range(rows):
        row = card_deck[i * cols : (i + 1) * cols]
        board.append(row)
    return board

async def render_memory_board(game: dict, is_finished: bool = False):
    """صفحه بازی حافظه را برای نمایش به کاربر رندر می‌کند."""
    game_id = game['game_id']
    p1 = game['players_info'][0]
    p2 = game['players_info'][1]

    if is_finished:
        text = (
            f"🧠 **بازی حافظه**\n\n"
            f"**امتیاز نهایی:**\n"
            f"🔵 {p1['name']}: {p1['score']}\n"
            f"🔴 {p2['name']}: {p2['score']}"
        )
    else:
        turn_player = next(p for p in game['players_info'] if p['id'] == game['turn'])
        text = (
            f"🧠 **بازی حافظه**\n\n"
            f"**امتیازها:**\n"
            f"🔵 {p1['name']}: {p1['score']}\n"
            f"🔴 {p2['name']}: {p2['score']}\n\n"
            f"**نوبت {turn_player['name']}** است."
        )
    
    board_view = game['board_view']
    keyboard = []
    for r, row_list in enumerate(board_view):
        row_buttons = []
        for c, cell_content in enumerate(row_list):
            callback_action = "noop" if is_finished else "flip"
            row_buttons.append(InlineKeyboardButton(cell_content, callback_data=f"memory_{callback_action}_{game_id}_{r}_{c}"))
        keyboard.append(row_buttons)
        
    return text, InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و بازنویسی شده ---
async def memory_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id

    data = query.data.split('_')
    action = data[1]

    # --- بخش شروع بازی (که در کد قبلی من خالی بود و اینجا اصلاح شده) ---
    if action == "start":
        await query.answer()
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['memory']:
            active_games['memory'][chat_id] = {}

        size_str = data[2]
        rows, cols = map(int, size_str.split('x'))

        sent_message = await query.message.reply_text(f"در حال ساخت بازی حافظه ({size_str})...")
        game_id = sent_message.message_id
        
        game = {
            "game_id": game_id, "status": "joining",
            "players_info": [{'id': user.id, 'name': user.first_name, 'score': 0}],
            "board_solution": generate_memory_board(rows, cols),
            "board_view": [['❔'] * cols for _ in range(rows)],
            "turn": None,
            "first_card": None,
            "is_checking": False,
            "matched_pairs": 0,
            "total_pairs": (rows * cols) // 2
        }
        active_games['memory'][chat_id][game_id] = game
        
        text = f"بازی حافظه ({size_str}) توسط {user.mention_html()} ساخته شد! منتظر حریف...\n\n( @RHINOSOUL_TM برای پیوستن به بازی، عضو کانال شوید)"
        keyboard = [[InlineKeyboardButton("پیوستن به بازی (1/2)", callback_data=f"memory_join_{game_id}")]]
        await sent_message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)
        
        try:
            await query.message.delete()
        except Exception: 
            pass
        return

    # --- بخش‌های دیگر بازی ---
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        await query.answer("خطای دکمه.", show_alert=True)
        return

    if chat_id not in active_games['memory'] or game_id not in active_games['memory'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['memory'][chat_id][game_id]

    # --- بخش پیوستن به بازی (که در کد قبلی من خالی بود و اینجا اصلاح شده) ---
    if action == "join":
        if not await check_join_for_alert(update, context):
            return

        await query.answer()
        if any(p['id'] == user.id for p in game['players_info']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
        if len(game['players_info']) >= 2:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            
        game['players_info'].append({'id': user.id, 'name': user.first_name, 'score': 0})
        game['status'] = 'playing'
        game['turn'] = game['players_info'][0]['id']

        text, reply_markup = await render_memory_board(game)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        return

    # --- بخش اصلی منطق بازی (نسخه کامل و اصلاح شده قبلی) ---
    elif action == "flip":
        if game.get('is_checking', False):
            await query.answer("لطفاً صبر کنید...", show_alert=False)
            return
        
        if user.id != game.get('turn'):
            await query.answer("نوبت شما نیست!", show_alert=True)
            return
        
        r, c = int(data[3]), int(data[4])
        
        if game['board_view'][r][c] != '❔':
            await query.answer("این کارت قبلاً انتخاب شده!", show_alert=True)
            return
        
        await query.answer()
        card_value = game['board_solution'][r][c]
        game['board_view'][r][c] = card_value

        if not game['first_card']:
            game['first_card'] = {'r': r, 'c': c, 'val': card_value}
            text, reply_markup = await render_memory_board(game)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        
        else:
            game['is_checking'] = True
            try:
                text, reply_markup = await render_memory_board(game)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
                await asyncio.sleep(1.5)
                
                first_card = game['first_card']
                
                if card_value == first_card['val'] and (r, c) != (first_card['r'], first_card['c']):
                    game['matched_pairs'] += 1
                    current_player = next(p for p in game['players_info'] if p['id'] == game['turn'])
                    current_player['score'] += 1
                else:
                    game['board_view'][r][c] = '❔'
                    game['board_view'][first_card['r']][first_card['c']] = '❔'
                    current_turn_id = game['turn']
                    next_player = next(p for p in game['players_info'] if p['id'] != current_turn_id)
                    game['turn'] = next_player['id']
            finally:
                game['first_card'] = None
                game['is_checking'] = False

            if game['matched_pairs'] == game['total_pairs']:
                p1 = game['players_info'][0]
                p2 = game['players_info'][1]
                
                if p1['score'] > p2['score']: winner = p1
                elif p2['score'] > p1['score']: winner = p2
                else: winner = None
                
                text, reply_markup = await render_memory_board(game, is_finished=True)
                
                if winner:
                    text += f"\n\n🏆 **برنده نهایی: {winner['name']}**"
                else:
                    text += "\n\n🤝 بازی **مساوی** شد!"
                
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
                del active_games['memory'][chat_id][game_id]
            else:
                text, reply_markup = await render_memory_board(game)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    
    elif action == "noop":
        await query.answer("این بازی تمام شده است.", show_alert=True)

# =========================== SAMEGAME CODE (START) ==========================
# --- توابع کمکی SameGame ---

def create_samegame_board():
    """یک صفحه بازی تصادفی برای بازی جفت‌ها ایجاد می‌کند."""
    return [[random.choice(SAMEGAME_COLORS) for _ in range(SAMEGAME_WIDTH)] for _ in range(SAMEGAME_HEIGHT)]

def find_samegame_group(board, r_start, c_start):
    """تمام بلوک‌های همرنگ و متصل را پیدا می‌کند."""
    target_color = board[r_start][c_start]
    if target_color == EMPTY_CELL:
        return []

    q = [(r_start, c_start)]
    group = set(q)
    
    while q:
        r, c = q.pop(0)
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (0 <= nr < SAMEGAME_HEIGHT and 0 <= nc < SAMEGAME_WIDTH and
                    board[nr][nc] == target_color and (nr, nc) not in group):
                group.add((nr, nc))
                q.append((nr, nc))
    return list(group)

# --- تابع بازنویسی شده برای پر کردن تصادفی ---
def refill_samegame_board_randomly(board):
    """خانه‌های خالی را با بلوک‌های رنگی تصادفی جدید پر می‌کند."""
    for r in range(SAMEGAME_HEIGHT):
        for c in range(SAMEGAME_WIDTH):
            if board[r][c] == EMPTY_CELL:
                board[r][c] = random.choice(SAMEGAME_COLORS)
    return board

def is_game_over_samegame(board):
    """بررسی می‌کند آیا حرکتی باقی مانده است یا خیر."""
    for r in range(SAMEGAME_HEIGHT):
        for c in range(SAMEGAME_WIDTH):
            if board[r][c] != EMPTY_CELL:
                if c + 1 < SAMEGAME_WIDTH and board[r][c] == board[r][c+1]:
                    return False
                if r + 1 < SAMEGAME_HEIGHT and board[r][c] == board[r+1][c]:
                    return False
    return True

async def render_samegame_board(game, is_finished=False):
    """صفحه بازی جفت‌ها را برای نمایش به کاربر رندر می‌کند."""
    game_id = game['game_id']
    board = game['board']
    score = game['score']
    
    text = f"✨ **بازی جفت‌ها (بی‌پایان)**\nامتیاز: **{score}**"
    
    if is_finished:
        text += f"\n\n☠️ **حرکت دیگری باقی نمانده! بازی تمام شد.**"
        # رندر کردن بورد نهایی بدون دکمه
        keyboard = []
        for r in range(SAMEGAME_HEIGHT):
            row_buttons = [InlineKeyboardButton(board[r][c], callback_data=f"samegame_noop_{game_id}") for c in range(SAMEGAME_WIDTH)]
            keyboard.append(row_buttons)
        return text, InlineKeyboardMarkup(keyboard)

    keyboard = []
    for r in range(SAMEGAME_HEIGHT):
        row_buttons = [InlineKeyboardButton(board[r][c], callback_data=f"samegame_click_{game_id}_{r}_{c}") for c in range(SAMEGAME_WIDTH)]
        keyboard.append(row_buttons)
        
    keyboard.append([InlineKeyboardButton("✖️ بستن بازی", callback_data=f"samegame_close_{game_id}")])
    
    return text, InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و بازنویسی شده SameGame ---
async def samegame_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id

    data = query.data.split('_')
    action = data[1]

    if action == "start":
        # ۱. پاسخ به کلیک کاربر اضافه شد

        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['samegame']:
            active_games['samegame'][chat_id] = {}
            
        if any(g['player_id'] == user.id for g in active_games['samegame'].get(chat_id, {}).values()):
            await query.answer("شما از قبل یک بازی فعال دارید.", show_alert=True)
            return
            await query.answer()
        sent_message = await query.message.reply_text("در حال ساخت بازی جفت‌ها...")
        game_id = sent_message.message_id
        
        game = { "game_id": game_id, "player_id": user.id, "board": create_samegame_board(), "score": 0 }
        active_games['samegame'][chat_id][game_id] = game
        
        text, reply_markup = await render_samegame_board(game)
        await sent_message.edit_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        
        try: 
            await query.message.delete()
        except Exception: 
            pass
        return

    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        return

    if chat_id not in active_games['samegame'] or game_id not in active_games['samegame'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['samegame'][chat_id][game_id]

    if user.id != game.get('player_id'):
        await query.answer("این بازی برای شما نیست!", show_alert=True)
        return
        
    if action == "click":
        try:
            r, c = int(data[3]), int(data[4])
        except (ValueError, IndexError):
            return

        group = find_samegame_group(game['board'], r, c)
        
        if len(group) < 2:
            await query.answer("باید حداقل دو بلوک همرنگ کنار هم باشند!", show_alert=True)
            return

        await query.answer()
        
        score_increment = len(group)
        game['score'] += score_increment
        
        for row, col in group:
            game['board'][row][col] = EMPTY_CELL
        
        game['board'] = refill_samegame_board_randomly(game['board'])

        if is_game_over_samegame(game['board']):
            text, reply_markup = await render_samegame_board(game, is_finished=True)
            await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
            del active_games['samegame'][chat_id][game_id]
        else:
            text, reply_markup = await render_samegame_board(game)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

    elif action == "close":
        await query.edit_message_text("بازی جفت‌ها بسته شد.")
        del active_games['samegame'][chat_id][game_id]
        
    elif action == "noop":
        await query.answer("این بازی تمام شده است.", show_alert=True)
        
# ============================ SAMEGAME CODE (END) ============================
# ======================== SLIDING PUZZLE CODE (START) - v2 =========================

# --- ثابت‌های پازل کشویی ---
SPUZZLE_SIZE = 4

# --- توابع کمکی پازل (منطق اصلی بدون تغییر) ---

def create_solvable_spuzzle():
    """یک پازل درهم‌ریخته اما قابل حل ایجاد می‌کند."""
    board = list(range(1, SPUZZLE_SIZE * SPUZZLE_SIZE)) + [0]
    
    flat_board = list(board)
    empty_pos = len(flat_board) - 1
    
    for _ in range(300): # تعداد حرکات برای درهم‌ریختن
        moves = []
        if empty_pos < SPUZZLE_SIZE * (SPUZZLE_SIZE - 1): moves.append('up')
        if empty_pos >= SPUZZLE_SIZE: moves.append('down')
        if empty_pos % SPUZZLE_SIZE < SPUZZLE_SIZE - 1: moves.append('left')
        if empty_pos % SPUZZLE_SIZE > 0: moves.append('right')
        
        move = random.choice(moves)
        
        if move == 'up':
            swap_with = empty_pos + SPUZZLE_SIZE
        elif move == 'down':
            swap_with = empty_pos - SPUZZLE_SIZE
        elif move == 'left':
            swap_with = empty_pos + 1
        else: # right
            swap_with = empty_pos - 1
            
        flat_board[empty_pos], flat_board[swap_with] = flat_board[swap_with], flat_board[empty_pos]
        empty_pos = swap_with

    return [flat_board[i:i+SPUZZLE_SIZE] for i in range(0, len(flat_board), SPUZZLE_SIZE)]


def is_spuzzle_solved(board):
    """بررسی می‌کند که آیا پازل حل شده است یا خیر."""
    solved_board = list(range(1, SPUZZLE_SIZE * SPUZZLE_SIZE)) + [0]
    current_flat_board = [cell for row in board for cell in row]
    return solved_board == current_flat_board

async def render_spuzzle(game):
    """صفحه پازل کشویی را رندر می‌کند."""
    game_id = game['game_id']
    board = game['board']
    
    text = "🔢 **پازل کشویی**\n\nاعداد را مرتب کنید:"
    
    keyboard = []
    for r in range(SPUZZLE_SIZE):
        row_buttons = []
        for c in range(SPUZZLE_SIZE):
            cell = board[r][c]
            text_cell = str(cell) if cell != 0 else " "
            row_buttons.append(InlineKeyboardButton(text_cell, callback_data=f"spuzzle_noop_{game_id}"))
        keyboard.append(row_buttons)
        
    keyboard.append([InlineKeyboardButton("⬆️", callback_data=f"spuzzle_move_{game_id}_up")])
    keyboard.append([
        InlineKeyboardButton("⬅️", callback_data=f"spuzzle_move_{game_id}_left"),
        InlineKeyboardButton("⬇️", callback_data=f"spuzzle_move_{game_id}_down"),
        InlineKeyboardButton("➡️", callback_data=f"spuzzle_move_{game_id}_right")
    ])
    keyboard.append([InlineKeyboardButton("✖️ بستن بازی", callback_data=f"spuzzle_close_{game_id}")])
    
    return text, InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و بازنویسی شده پازل ---
async def spuzzle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user = query.from_user
    chat_id = query.message.chat.id

    data = query.data.split('_')
    action = data[1]

    if action == "start":
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['spuzzle']:
            active_games['spuzzle'][chat_id] = {}
        
        if any(g['player_id'] == user.id for g in active_games['spuzzle'].get(chat_id, {}).values()):
            await query.answer("شما از قبل یک پازل فعال دارید.", show_alert=True)
            return

        sent_message = await query.message.reply_text("در حال ساخت پازل کشویی...")
        game_id = sent_message.message_id
        
        game = {
            "game_id": game_id, "player_id": user.id,
            "board": create_solvable_spuzzle(),
            "start_time": time.time(),
            "is_busy": False
        }
        active_games['spuzzle'][chat_id][game_id] = game
        
        text, reply_markup = await render_spuzzle(game)
        await sent_message.edit_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        return

    if chat_id not in active_games['spuzzle'] or game_id not in active_games['spuzzle'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['spuzzle'][chat_id][game_id]

    if user.id != game.get('player_id'):
        await query.answer("این بازی برای شما نیست!", show_alert=True)
        return

    if game.get('is_busy', False):
        return

    if action == "move":
        game['is_busy'] = True
        try:
            direction = data[3]
            board = game['board']
            empty_r, empty_c = -1, -1
            for r_idx, row in enumerate(board):
                if 0 in row:
                    empty_r, empty_c = r_idx, row.index(0)
                    break

            tile_r, tile_c = empty_r, empty_c
            if direction == 'up': tile_r += 1
            elif direction == 'down': tile_r -= 1
            elif direction == 'left': tile_c += 1
            elif direction == 'right': tile_c -= 1
            
            if 0 <= tile_r < SPUZZLE_SIZE and 0 <= tile_c < SPUZZLE_SIZE:
                board[empty_r][empty_c], board[tile_r][tile_c] = board[tile_r][tile_c], board[empty_r][empty_c]

                if is_spuzzle_solved(board):
                    duration = time.time() - game['start_time']
                    
                    final_text = (
                        f"🏆 **تبریک {user.mention_html()}!** 🏆\n\n"
                        f"شما پازل را در زمان **{int(duration)} ثانیه** حل کردید!"
                    )
                    
                    final_board_text, _ = await render_spuzzle(game)
                    
                    await query.edit_message_text(
                        f"{final_board_text}\n\n{final_text}",
                        reply_markup=None,
                        parse_mode=ParseMode.HTML
                    )
                    del active_games['spuzzle'][chat_id][game_id]
                    return
                
                text, reply_markup = await render_spuzzle(game)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
            else:
                await query.answer("حرکت غیرمجاز!")
        finally:
            if chat_id in active_games['spuzzle'] and game_id in active_games['spuzzle'][chat_id]:
                active_games['spuzzle'][chat_id][game_id]['is_busy'] = False

    elif action == "close":
        await query.edit_message_text("پازل کشویی بسته شد.")
        del active_games['spuzzle'][chat_id][game_id]

    elif action == "noop":
        pass

# ========================= SLIDING PUZZLE CODE (END) - v2 ==========================
# ======================== 4-PLAYER DOZ CODE (START) =========================

# --- ثابت‌های دوز چهار نفره ---
DOZ4P_SIZE = 10
DOZ4P_SYMBOLS = ["🔴", "🔵", "🟢", "🟡"]

# --- توابع کمکی (منطق اصلی بدون تغییر) ---

def check_doz4p_winner(board, symbol):
    """بررسی می‌کند که آیا بازیکنی با نماد 'symbol' برنده شده است (۴ مهره در یک ردیف)."""
    # بررسی افقی
    for r in range(DOZ4P_SIZE):
        for c in range(DOZ4P_SIZE - 3):
            if all(board[r][c+i] == symbol for i in range(4)):
                return True
    # بررسی عمودی
    for r in range(DOZ4P_SIZE - 3):
        for c in range(DOZ4P_SIZE):
            if all(board[r+i][c] == symbol for i in range(4)):
                return True
    # بررسی مورب (پایین به بالا)
    for r in range(3, DOZ4P_SIZE):
        for c in range(DOZ4P_SIZE - 3):
            if all(board[r-i][c+i] == symbol for i in range(4)):
                return True
    # بررسی مورب (بالا به پایین)
    for r in range(DOZ4P_SIZE - 3):
        for c in range(DOZ4P_SIZE - 3):
            if all(board[r+i][c+i] == symbol for i in range(4)):
                return True
    return False

# --- تابع رندر بهینه‌سازی شده ---

async def render_doz4p_board(game, is_finished=False):
    """صفحه بازی دوز چهار نفره را رندر می‌کند."""
    game_id = game['game_id']
    board = game['board']
    player_list = "\n".join(f"{p['symbol']} {p['name']}" for p in game['players_info'])

    if is_finished:
        text = f"💠 **دوز چهار نفره (تمام شد)**\n\n{player_list}"
    else:
        turn_player = game['players_info'][game['turn_index']]
        text = f"💠 **دوز چهار نفره**\n\n{player_list}\n\nنوبت: {turn_player['symbol']} {turn_player['name']}"
    
    keyboard = []
    for r in range(DOZ4P_SIZE):
        row_buttons = []
        for c in range(DOZ4P_SIZE):
            callback_action = "noop" if is_finished else "move"
            row_buttons.append(InlineKeyboardButton(board[r][c], callback_data=f"doz4p_{callback_action}_{game_id}_{r}_{c}"))
        keyboard.append(row_buttons)
        
    return text, InlineKeyboardMarkup(keyboard)

# --- تابع اصلی و بازنویسی شده دوز ۴ نفره ---

async def doz4p_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id

    # if await check_ban_status(update, context): return
    
    data = query.data.split('_')
    action = data[1]

    if action == "start":
        # << امنیتی: بررسی مالکیت پنل >>
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
            return

        if chat_id not in active_games['doz4p']:
            active_games['doz4p'] = {chat_id: {}}
        
        sent_message = await query.message.reply_text("در حال ساخت بازی دوز چهار نفره...")
        game_id = sent_message.message_id
        
        game = {
            "game_id": game_id, "status": "joining",
            "players_info": [{'id': user.id, 'name': user.first_name, 'symbol': DOZ4P_SYMBOLS[0]}],
            "board": [['▪️'] * DOZ4P_SIZE for _ in range(DOZ4P_SIZE)],
            "turn_index": 0
        }
        active_games['doz4p'][chat_id][game_id] = game
        
        text = f"بازی دوز چهار نفره توسط {user.mention_html()} ساخته شد! (1/4)\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)"
        keyboard = [[InlineKeyboardButton("پیوستن به بازی", callback_data=f"doz4p_join_{game_id}")]]
        await sent_message.edit_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        return

    if chat_id not in active_games['doz4p'] or game_id not in active_games['doz4p'][chat_id]:
        await query.answer("این بازی دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['doz4p'][chat_id][game_id]

    if action == "join":
        if not await check_join_for_alert(update, context):
            return

        if any(p['id'] == user.id for p in game['players_info']):
            await query.answer("شما قبلاً به بازی پیوسته‌اید!", show_alert=True)
            return
        
        num_players = len(game['players_info'])
        if num_players >= 4:
            await query.answer("ظرفیت بازی تکمیل است.", show_alert=True)
            return
            await query.answer()
        game['players_info'].append({'id': user.id, 'name': user.first_name, 'symbol': DOZ4P_SYMBOLS[num_players]})
        
        if num_players + 1 < 4:
            player_names = "، ".join([p['name'] for p in game['players_info']])
            text = f"بازی دوز چهار نفره ({num_players + 1}/4)\n\nبازیکنان فعلی: {player_names}\n\n( @RHINOSOUL_TM برای پیوستن به بازی، باید در کانال عضو باشید)"
            keyboard = [[InlineKeyboardButton("پیوستن به بازی", callback_data=f"doz4p_join_{game_id}")]]
            await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)
        else:
            game['status'] = 'playing'
            text, reply_markup = await render_doz4p_board(game)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

    elif action == "move":
        if game.get('status') != 'playing':
            await query.answer("بازی تمام شده است.", show_alert=True)
            return

        turn_player = game['players_info'][game['turn_index']]
        if user.id != turn_player['id']:
            await query.answer("نوبت شما نیست!", show_alert=True)
            return
        
        r, c = int(data[3]), int(data[4])
        if game['board'][r][c] != '▪️':
            await query.answer("این خانه پر است!", show_alert=True)
            return
        
        symbol = turn_player['symbol']
        game['board'][r][c] = symbol

        is_winner = check_doz4p_winner(game['board'], symbol)
        is_draw = all(cell != '▪️' for row in game['board'] for cell in row) and not is_winner

        if is_winner or is_draw:
            game['status'] = 'finished'
            text, reply_markup = await render_doz4p_board(game, is_finished=True)
            
            if is_winner:
                text += f"\n\n🏆 برنده: {turn_player['symbol']} {turn_player['name']}"
            else:
                text += "\n\n🤝 بازی مساوی شد!"
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
            del active_games['doz4p'][chat_id][game_id]
        else:
            game['turn_index'] = (game['turn_index'] + 1) % 4
            text, reply_markup = await render_doz4p_board(game)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

    elif action == "noop":
        await query.answer("این بازی تمام شده است.", show_alert=True)

# ======================== GARDONE SHANS (START) =========================

async def render_gardone_board(game: dict):
    """صفحه گردونه شانس را با لیست شرکت‌کنندگان و دکمه‌ها می‌سازد."""
    game_id = game['game_id']
    starter_admin_id = game['starter_admin_id']
    participants = game['participants']
    
    participant_list = "هنوز کسی ثبت نام نکرده است."
    if participants:
        # لیست شرکت‌کنندگان را با منشن کردن نامشان می‌سازیم
        participant_list = "\n".join([f"👤 {p['name']}" for p in participants])

    text = f"🎡 **گردونه شانس فعال است!** 🎡\n\nابتدا عضو کانال شوید @RHINOSOUL_TM " \
           f"سپس برای شرکت در قرعه‌کشی روی دکمه «پیوستن» کلیک کنید.\n\n" \
           f"**لیست شرکت‌کنندگان ({len(participants)} نفر):**\n" \
           f"{participant_list}"

    keyboard = [
        [InlineKeyboardButton("✅ پیوستن به گردونه", callback_data=f"gardone_join_{game_id}")],
        [InlineKeyboardButton("🎰 چرخاندن گردونه", callback_data=f"gardone_spin_{game_id}_{starter_admin_id}")],
        [InlineKeyboardButton("❌ لغو گردونه", callback_data=f"gardone_cancel_{game_id}_{starter_admin_id}")],
    ]
    return text, InlineKeyboardMarkup(keyboard)

async def gardone_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id
    
    data = query.data.split('_')
    action = data[1]

    if action == "start":
        await query.answer()
        
        # بررسی مالکیت پنل
        try:
            target_user_id = int(data[-1])
            if user.id != target_user_id:
                await query.answer("این پنل برای شما نیست!", show_alert=True)
                return
        except (ValueError, IndexError):
            return

        # بررسی اینکه کاربر ادمین است
        if not await is_group_admin(user.id, chat_id, context):
            await query.answer("این بخش فقط برای مدیران گروه است.", show_alert=True)
            return

        # جلوگیری از شروع چند گردونه همزمان در یک گروه
        if chat_id in active_games['gardone']:
            await query.answer("یک گردونه شانس در این گروه فعال است.", show_alert=True)
            return
            
        sent_message = await query.message.reply_text("در حال آماده‌سازی گردونه شانس...")
        game_id = sent_message.message_id
        
        game = {
            "game_id": game_id,
            "starter_admin_id": user.id, # شناسه ادمینی که بازی را ساخته
            "participants": [] # لیست خالی برای شرکت‌کنندگان
        }
        active_games['gardone'][chat_id] = game
        
        text, reply_markup = await render_gardone_board(game)
        await sent_message.edit_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
        
        try:
            await query.message.delete()
        except Exception:
            pass
        return

    # استخراج game_id از callback_data برای اکشن‌های دیگر
    try:
        game_id = int(data[2])
    except (ValueError, IndexError):
        return

    if chat_id not in active_games['gardone'] or active_games['gardone'][chat_id]['game_id'] != game_id:
        await query.answer("این گردونه شانس دیگر فعال نیست.", show_alert=True)
        return
        
    game = active_games['gardone'][chat_id]

    if action == "join":
        # ۱. ابتدا عضویت در کانال را چک می‌کنیم
        if not await check_join_for_alert(update, context):
            return # اگر عضو نباشد، تابع چک خودش هشدار می‌دهد و خارج می‌شود

        # ۲. چک می‌کنیم که کاربر قبلاً نپیوسته باشد
        if any(p['id'] == user.id for p in game['participants']):
            await query.answer("شما قبلاً در این قرعه‌کشی شرکت کرده‌اید!", show_alert=True)
            return

        # ۳. کاربر را به لیست اضافه می‌کنیم
        game['participants'].append({'id': user.id, 'name': user.first_name})
        await query.answer("شما با موفقیت به گردونه شانس پیوستید!")
        
        # ۴. پیام را با لیست جدید به‌روزرسانی می‌کنیم
        text, reply_markup = await render_gardone_board(game)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    elif action == "spin":
        starter_admin_id = int(data[3])
        if user.id != starter_admin_id:
            await query.answer("فقط ادمینی که گردونه را ساخته، می‌تواند آن را بچرخاند!", show_alert=True)
            return

        if not game['participants']:
            await query.answer("هیچ‌کس در قرعه‌کشی شرکت نکرده است!", show_alert=True)
            return

        await query.answer("گردونه در حال چرخش است...")
        winner = random.choice(game['participants'])
        
        final_text = f"🎉 **برنده مشخص شد!** 🎉\n\n" \
                     f"تبریک به **{winner['name']}** عزیز!\nشما برنده خوش‌شانس این گردونه بودید."
        
        await query.edit_message_text(final_text, reply_markup=None, parse_mode=ParseMode.HTML)
        del active_games['gardone'][chat_id]

    elif action == "cancel":
        starter_admin_id = int(data[3])
        if user.id != starter_admin_id:
            await query.answer("فقط ادمینی که گردونه را ساخته، می‌تواند آن را لغو کند!", show_alert=True)
            return
            
        await query.edit_message_text("🎡 گردونه شانس توسط ادمین لغو شد.")
        del active_games['gardone'][chat_id]
        
# ========================= GARDONE SHANS (END) ==========================
# ======================== 4-PLAYER DOZ CODE (END) =========================
# --------------------------- GAME: HADS KALAME (با جان جداگانه) ---------------------------
async def hads_kalame_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
        await query.answer()
    
    if await check_ban_status(update, context): return
    
    chat_id = update.effective_chat.id
    if chat_id in active_games['hangman']:
        await query.answer("یک بازی حدس کلمه فعال است.", show_alert=True)
        return
        
    word = random.choice(WORD_LIST)
    active_games['hangman'][chat_id] = {"word": word, "display": ["_"] * len(word), "guessed_letters": set(), "players": {}}
    game = active_games['hangman'][chat_id]
    text = f"🕵️‍♂️ **حدس کلمه (رقابتی) شروع شد!**\n\nهر کاربر {INITIAL_LIVES} جان دارد.\n\n|نکته*:|به صورت تک حرفی حدس بزنید.مثال:(م)*\n\nکلمه: `{' '.join(game['display'])}`"
    await query.edit_message_text(text, parse_mode=ParseMode.MARKDOWN)

async def handle_letter_guess(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id, user = update.effective_chat.id, update.effective_user
    if chat_id not in active_games['hangman']: return
    if await check_ban_status(update, context): return

    guess = update.message.text.strip()
    game = active_games['hangman'][chat_id]
    
    if user.id not in game['players']: game['players'][user.id] = INITIAL_LIVES
    if game['players'][user.id] == 0: 
        await update.message.reply_text(f"{user.mention_html()}، شما تمام جان‌های خود را از دست داده‌اید!", parse_mode=ParseMode.HTML)
        return

    # ##### تغییر کلیدی: اطلاع‌رسانی برای حرف تکراری #####
    if guess in game['guessed_letters']:
        await update.message.reply_text("این حرف قبلاً گفته شده!", quote=True)
        return

    game['guessed_letters'].add(guess)
    if guess in game['word']:
        for i, letter in enumerate(game['word']):
            if letter == guess: game['display'][i] = letter
        if "_" not in game['display']:
            await update.message.reply_text(f"✅ **{user.mention_html()}** برنده شد! کلمه صحیح `{game['word']}` بود.", parse_mode=ParseMode.HTML, reply_markup=None)
            del active_games['hangman'][chat_id]
        else:
            await update.message.reply_text(f"`{' '.join(game['display'])}`", parse_mode=ParseMode.MARKDOWN)
    else:
        game['players'][user.id] -= 1
        lives_left = game['players'][user.id]
        if lives_left > 0:
            await update.message.reply_text(f"اشتباه بود {user.mention_html()}! شما **{lives_left}** جان دیگر دارید.", parse_mode=ParseMode.HTML)
        else:
            await update.message.reply_text(f"{user.mention_html()} تمام جان‌های خود را از دست داد و از بازی حذف شد.", parse_mode=ParseMode.HTML)
            # چک کردن اینکه آیا همه بازیکنان حذف شده‌اند یا خیر
            active_players_lives = [lives for uid, lives in game['players'].items() if lives > 0]
            if not active_players_lives:
                await update.message.reply_text(f"☠️ همه باختید! کلمه صحیح `{game['word']}` بود.", parse_mode=ParseMode.MARKDOWN)
                del active_games['hangman'][chat_id]

# --------------------------- GAME: TYPE SPEED ---------------------------
def create_typing_image(text: str) -> io.BytesIO:
    reshaped_text = arabic_reshaper.reshape(text)
    bidi_text = get_display(reshaped_text)
    try:
        font = ImageFont.truetype("Vazir.ttf", 24)
    except IOError:
        logger.warning("Vazir.ttf font not found. Falling back to default.")
        font = ImageFont.load_default()
    
    dummy_img, draw = Image.new('RGB', (1, 1)), ImageDraw.Draw(Image.new('RGB', (1, 1)))
    _, _, w, h = draw.textbbox((0, 0), bidi_text, font=font)
    img = Image.new('RGB', (w + 40, h + 40), color=(255, 255, 255))
    ImageDraw.Draw(img).text((20, 20), bidi_text, fill=(0, 0, 0), font=font)
    bio = io.BytesIO()
    bio.name = 'image.jpeg'
    img.save(bio, 'JPEG')
    bio.seek(0)
    return bio

async def type_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
        await query.answer()

    if await check_ban_status(update, context): return
    
    chat_id = update.effective_chat.id
    if chat_id in active_games['typing']: 
        await query.answer("یک بازی تایپ سرعتی فعال است.", show_alert=True)
        return
        
    sentence = random.choice(TYPING_SENTENCES)
    active_games['typing'][chat_id] = {"sentence": sentence, "start_time": datetime.now()}
    
    await query.edit_message_text("بازی تایپ سرعتی ۳... ۲... ۱...")
    image_file = create_typing_image(sentence)
    await context.bot.send_photo(chat_id=chat_id, photo=image_file, caption="سریع تایپ کنید!")

async def handle_typing_attempt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if chat_id not in active_games['typing']: return
    if await check_ban_status(update, context): return
    
    game = active_games['typing'][chat_id]
    user_input = update.message.text.strip()
    
    if user_input == game['sentence']:
        duration = (datetime.now() - game['start_time']).total_seconds()
        user = update.effective_user
        await update.message.reply_text(f"🏆 {user.mention_html()} برنده شد!\nزمان: **{duration:.2f}** ثانیه", parse_mode=ParseMode.HTML)
        del active_games['typing'][chat_id]

#--------------------------- GAME: GHARCH & ETERAF ---------------------------
#(منطق این بازی‌ها عمدتاً بدون تغییر است، فقط نحوه شروع آنها از پنل اضافه شده)
async def gharch_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = query.from_user
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
        await query.answer()
    
    if await check_ban_status(update, context): return ConversationHandler.END

    if not await is_group_admin(update.effective_user.id, update.effective_chat.id, context):
        await query.answer("❌ فقط ادمین‌های گروه می‌توانند این بازی را شروع کنند.", show_alert=True)
        return ConversationHandler.END
    
    context.chat_data['starter_admin_id'] = update.effective_user.id
    await query.edit_message_text(
        "🍄 **شروع بازی قارچ**\n\n"
        "لطفاً یوزرنیم گاد بازی را ارسال کنید (مثال: @GodUsername).\nبرای لغو /cancel را ارسال کنید."
    )
    context.chat_data['gharch_setup_message_id'] = query.message.message_id
    return ASKING_GOD_USERNAME

async def receive_god_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    starter_admin_id = context.chat_data.get('starter_admin_id')
    current_user_id = update.effective_user.id

    # اگر کاربری که پیام داده، همان ادمینی نیست که بازی را شروع کرده، پیام را نادیده بگیر
    if current_user_id != starter_admin_id:
        return ASKING_GOD_USERNAME # در همان وضعیت باقی بمان و هیچ کاری نکن
    # --- پایان بخش جدید ---
    
    god_username = update.message.text.strip()
    if not god_username.startswith('@'):
        await update.message.reply_text("فرمت اشتباه است. لطفاً یوزرنیم را با @ ارسال کنید.", quote=True)
        return ASKING_GOD_USERNAME

    context.chat_data['god_username'] = god_username
    starter_admin_id = context.chat_data['starter_admin_id']
    setup_message_id = context.chat_data.get('gharch_setup_message_id')

    try:
        await update.message.delete()
    except Exception as e:
        logger.warning(f"Could not delete admin's username message: {e}")

    if not setup_message_id:
        await context.bot.send_message(update.effective_chat.id, "خطایی در یافتن پیام اصلی رخ داد. لطفاً بازی را با /cancel لغو و مجدداً شروع کنید.")
        return ConversationHandler.END

    keyboard = [[
        InlineKeyboardButton("✅ تایید می‌کنم", callback_data=f"gharch_confirm_god_{starter_admin_id}")
    ]]
    
    await context.bot.edit_message_text(
        chat_id=update.effective_chat.id,
        message_id=setup_message_id,
        text=(
            f"{god_username} عزیز،\n"
            f"شما به عنوان گاد بازی قارچ انتخاب شدید. لطفاً برای شروع بازی، این مسئولیت را تایید کنید.\n\n"
            f"⚠️ **نکته:** برای دریافت گزارش‌ها، باید ربات را استارت کرده باشید."
        ),
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return CONFIRMING_GOD

async def confirm_god(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """گاد بازی را تایید کرده و بازی رسماً شروع می‌شود."""
    query = update.callback_query
    user = query.from_user
    chat_id = query.message.chat.id
    
    god_username_from_admin = context.chat_data.get('god_username', '').lower().lstrip('@')

    if not user.username or user.username.lower() != god_username_from_admin:
        await query.answer("این درخواست برای شما نیست، یا یوزرنیم تلگرام شما تنظیم نشده است.", show_alert=True)
        return CONFIRMING_GOD

    await query.answer("شما به عنوان گاد تایید شدید!")

    try:
        god_id = user.id
        god_username_display = f"@{user.username}"
        active_gharch_games[chat_id] = {'god_id': god_id, 'god_username': god_username_display}

        bot_username = (await context.bot.get_me()).username
        game_message_text = (
            "**بازی قارچ 🍄 شروع شد!**\n\n"
            "روی دکمه زیر کلیک کن و حرف دلت رو بنویس تا به صورت ناشناس در گروه ظاهر بشه!\n\n"
            f"*(فقط گاد بازی، {god_username_display}، از هویت ارسال‌کننده مطلع خواهد شد.)*"
        )
        keyboard = [[InlineKeyboardButton("🍄 ارسال پیام ناشناس", url=f"https://t.me/{bot_username}?start=gharch_{chat_id}")]]
        
        await query.edit_message_text(
            text=game_message_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode=ParseMode.MARKDOWN
        )
        
        try:
            await context.bot.pin_chat_message(chat_id, query.message.message_id)
            active_gharch_games[chat_id]['pinned_message_id'] = query.message.message_id
        except Exception as pin_error:
            logger.warning(f"Could not pin message in group {chat_id}. Reason: {pin_error}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="✅ بازی با موفقیت شروع شد. ادمین‌های عزیز، لطفاً این پیام را پین کنید.",
                reply_to_message_id=query.message.message_id
            )

    except Exception as e:
        error_message = f"🚫 **خطای ناشناخته!**\n\nربات در ساخت بازی با یک خطای غیرمنتظره مواجه شد: `{e}`"
        await context.bot.send_message(chat_id=chat_id, text=error_message, parse_mode=ParseMode.MARKDOWN)
        logger.error(f"CRITICAL ERROR in confirm_god: {e}")
        return ConversationHandler.END

    return ConversationHandler.END

async def cancel_gharch_conv(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """لغو فرآیند ساخت بازی قارچ."""
    await update.message.reply_text("فرآیند ساخت بازی قارچ لغو شد.")
    await rsgame_command(update, context)
    return ConversationHandler.END

async def eteraf_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split('_')
    try:
        target_user_id = int(data[-1])
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return

    if user.id != target_user_id:
        await query.answer("این پنل برای شما نیست!", show_alert=True)
        return
        await query.answer()

    if await check_ban_status(update, context): return
    
    user = update.effective_user
    chat_id = update.effective_chat.id
    if not await is_group_admin(user.id, chat_id, context):
        await query.answer("❌ شما اجازه استفاده از این دستور را ندارید.", show_alert=True)
        return
    
    data = query.data.split('_')
    eteraf_type = data[2] 

    if eteraf_type == "default":
        starter_text = "یک موضوع اعتراف جدید شروع شد. برای ارسال اعتراف ناشناس، از دکمه زیر استفاده کنید."
        bot_username = (await context.bot.get_me()).username
        try:
            starter_message = await context.bot.send_message(chat_id, starter_text)
            keyboard = [[InlineKeyboardButton("ارسال به صورت ناشناس", url=f"https://t.me/{bot_username}?start=eteraf_{chat_id}_{starter_message.message_id}")]]
            await starter_message.edit_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard))
            await query.message.delete() 
        except Exception as e:
            logger.error(f"Error in eteraf_command: {e}")
        return

    elif eteraf_type == "custom":
        # ##### تغییر جدید: ذخیره آیدی پیام برای حذف در آینده #####
        context.chat_data['starter_admin_id'] = query.from_user.id
        context.chat_data['eteraf_prompt_message_id'] = query.message.message_id
        await query.edit_message_text("لطفاً متن دلخواه خود را برای شروع اعتراف ارسال کنید.\nبرای لغو /cancel را ارسال کنید.")
        return ENTERING_ETERAF_TEXT

async def receive_eteraf_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # --- بخش جدید برای بررسی شناسه کاربر ---
    starter_admin_id = context.chat_data.get('starter_admin_id')
    current_user_id = update.effective_user.id

    # اگر کاربری که پیام داده، همان ادمینی نیست که بازی را شروع کرده، پیام را نادیده بگیر
    if current_user_id != starter_admin_id:
        return ENTERING_ETERAF_TEXT # در همین وضعیت منتظر بمان و کاری نکن
    # --- پایان بخش جدید ---
    custom_text = update.message.text
    chat_id = update.effective_chat.id
    bot_username = (await context.bot.get_me()).username
    
    try:
        # ربات پیام جدید اعتراف را با دکمه ارسال می‌کند
        starter_message = await context.bot.send_message(chat_id, custom_text)
        keyboard = [[InlineKeyboardButton("ارسال به صورت ناشناس", url=f"https://t.me/{bot_username}?start=eteraf_{chat_id}_{starter_message.message_id}")]]
        await starter_message.edit_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        logger.error(f"Error in eteraf_command (custom): {e}")
        await update.message.reply_text(f"خطایی در ارسال پیام رخ داد: {e}")
    finally:
        # پیام قبلی ربات ("لطفا متن خود را ارسال کنید") حذف می‌شود
        prompt_message_id = context.chat_data.pop('eteraf_prompt_message_id', None)
        try:
            if prompt_message_id:
                await context.bot.delete_message(chat_id=chat_id, message_id=prompt_message_id)
            
            # ##### تغییر اصلی: خط زیر حذف شد #####
            # await update.message.delete() # -> این خط دیگر وجود ندارد و پیام شما باقی می‌ماند.

        except Exception:
            pass
            
        return ConversationHandler.END

async def handle_anonymous_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data = context.user_data
    if 'anon_target_chat' not in user_data:
        return await update.message.reply_text("لطفاً ابتدا از طریق دکمه‌ای که در گروه قرار دارد، فرآیند را شروع کنید.")
    
    target_info = user_data['anon_target_chat']
    target_chat_id = target_info['id']
    game_type = target_info['type']
    message_text = update.message.text

    try:
        if game_type == "gharch":
            if target_chat_id in active_gharch_games:
                sender = update.effective_user
                god_info = active_gharch_games[target_chat_id]
                god_id = god_info['god_id']

                await context.bot.send_message(
                    chat_id=target_chat_id,
                    text=f"#پیام_ناشناس 🍄\n\n{message_text}"
                )
                await update.message.reply_text("✅ پیام شما با موفقیت به صورت ناشناس در گروه ارسال شد.")

                report_text = (
                    f"📝 **گزارش پیام ناشناس جدید**\n\n"
                    f"👤 **ارسال کننده:**\n"
                    f"- نام: {sender.mention_html()}\n"
                    f"- یوزرنیم: @{sender.username}\n"
                    f"- آیدی: `{sender.id}`\n\n"
                    f"📜 **متن پیام:**\n"
                    f"{message_text}"
                )
                await context.bot.send_message(chat_id=god_id, text=report_text, parse_mode=ParseMode.HTML)
            else:
                await update.message.reply_text("این بازی قارچ دیگر فعال نیست یا منقضی شده است.")

        elif game_type == "eteraf":
            reply_to_id = target_info.get('reply_to')
            header = "#اعتراف_ناشناس 🤫"
            await context.bot.send_message(
                chat_id=target_chat_id,
                text=f"{header}\n\n{message_text}",
                reply_to_message_id=reply_to_id
            )
            await update.message.reply_text("✅ اعتراف شما با موفقیت به صورت ناشناس در گروه ارسال شد.")
        
        else:
            await update.message.reply_text("نوع بازی ناشناس مشخص نیست.")

    except Exception as e:
        await update.message.reply_text(f"⚠️ ارسال پیام با خطا مواجه شد: {e}")
        logger.error(f"Error in handle_anonymous_message for game {game_type}: {e}")
    finally:
        if 'anon_target_chat' in context.user_data:
            del context.user_data['anon_target_chat']


# =================================================================
# ================= OWNER & CORE COMMANDS (بدون تغییر) =============
# =================================================================
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id

    if await check_ban_status(update, context): return

    # --- بخش ۱: مدیریت لینک‌های ورودی (Deep Linking) ---
    if context.args:
        try:
            payload = context.args[0]
            parts = payload.split('_')
            game_type, target_chat_id = parts[0], int(parts[1])

            if game_type == "gharch":
                if target_chat_id in active_gharch_games:
                    god_username = active_gharch_games[target_chat_id]['god_username']
                    context.user_data['anon_target_chat'] = {'id': target_chat_id, 'type': game_type}
                    prompt = f"پیام خود را برای ارسال ناشناس بنویسید...\n\nتوجه: فقط گاد بازی ({god_username}) هویت شما را خواهد دید."
                    await update.message.reply_text(prompt)
                    return
                else:
                    await update.message.reply_text("این بازی قارچ دیگر فعال نیست."); return
            
            elif game_type == "eteraf":
                context.user_data['anon_target_chat'] = {'id': target_chat_id, 'type': game_type}
                if len(parts) > 2:
                    context.user_data['anon_target_chat']['reply_to'] = int(parts[2])
                prompt = "اعتراف خود را بنویسید تا به صورت ناشناس در گروه ارسال شود..."
                await update.message.reply_text(prompt)
                return

        except (ValueError, IndexError):
            pass # اگر payload معتبر نبود، به بخش استارت معمولی می‌رود

    # --- بخش ۲: منطق استارت معمولی ---
    conn = get_db_connection()
    if conn:
        with conn.cursor() as cur: 
            cur.execute("INSERT INTO users (user_id, first_name, username) VALUES (%s, %s, %s) ON CONFLICT (user_id) DO NOTHING;", (user.id, user.first_name, user.username))
            conn.commit()
    
    # اینجا عضویت اجباری برای استارت معمولی چک نمی‌شود، فقط در بازی‌های خاص
    
    # --- بخش ۳: ارسال پیام خوشامدگویی (سفارشی یا پیش‌فرض) ---
    keyboard = [
        [InlineKeyboardButton("➕ افزودن ربات به گروه", url=f"https://t.me/{(await context.bot.get_me()).username}?startgroup=true")],
        #[InlineKeyboardButton("🎮 پنل بازی‌ها", callback_data="rsgame_cat_main_pv")], # دکمه پنل در PV
        [InlineKeyboardButton("👤 ارتباط با پشتیبان", url=f"https://t.me/{SUPPORT_USERNAME}")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    custom_welcome_sent = False
    if conn:
        try:
            with conn.cursor() as cur:
                cur.execute("SELECT message_id, chat_id FROM start_message WHERE id = 1;")
                start_msg_data = cur.fetchone()
                if start_msg_data:
                    message_id, from_chat_id = start_msg_data
                    await context.bot.copy_message(chat_id=chat_id, from_chat_id=from_chat_id, message_id=message_id, reply_markup=reply_markup)
                    custom_welcome_sent = True
        except Exception as e:
            logger.error(f"Could not send custom start message in PV: {e}")
        finally:
            conn.close()

    if not custom_welcome_sent:
        await update.message.reply_text("سلام به راینوبازی خوش آمدید.\nبرای شروع بازی‌ها از دکمه زیر استفاده کنید.", reply_markup=reply_markup)
    
    report_text = f"✅ کاربر جدید: {user.mention_html()} (ID: `{user.id}`)"
    for owner_id in OWNER_IDS:
        try:
            await context.bot.send_message(chat_id=owner_id, text=report_text, parse_mode=ParseMode.HTML)
        except:
            pass
            
async def rsgame_pv_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """هنگامی که کاربر در PV روی دکمه پنل کلیک می‌کند"""
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("این پنل فقط در گروه‌ها کار می‌کند. لطفاً ربات را به یک گروه اضافه کرده و دستور /rsgame را ارسال کنید.")


# بقیه دستورات ادمین (stats, fwdusers, ...) بدون تغییر باقی می‌مانند
# ...
async def set_start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    if not update.message.reply_to_message: return await update.message.reply_text("روی یک پیام ریپلای کنید.")
    msg = update.message.reply_to_message
    conn = get_db_connection()
    if conn:
        with conn.cursor() as cur: cur.execute("INSERT INTO start_message (id, message_id, chat_id) VALUES (1, %s, %s) ON CONFLICT (id) DO UPDATE SET message_id = EXCLUDED.message_id, chat_id = EXCLUDED.chat_id;", (msg.message_id, msg.chat_id)); conn.commit()
        conn.close()
        await update.message.reply_text("✅ پیام خوشامدگویی تنظیم شد.")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    conn = get_db_connection()
    if conn:
        with conn.cursor() as cur:
            cur.execute("SELECT COUNT(*) FROM users;"); user_count = cur.fetchone()[0]
            cur.execute("SELECT COUNT(*) FROM groups;"); group_count = cur.fetchone()[0]
            cur.execute("SELECT SUM(member_count) FROM groups;"); total_members = cur.fetchone()[0] or 0
        stats = f"📊 **آمار ربات**\n\n👤 کاربران: {user_count}\n👥 گروه‌ها: {group_count}\n👨‍👩‍👧‍👦 مجموع اعضا: {total_members}"
        await update.message.reply_text(stats, parse_mode=ParseMode.MARKDOWN)
        conn.close()
        
async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE, target: str):
    if not await is_owner(update.effective_user.id): return
    if not update.message.reply_to_message: return await update.message.reply_text("روی یک پیام ریپلای کنید.")
    conn, table, column = get_db_connection(), "users" if target == "users" else "groups", "user_id" if target == "users" else "group_id"
    if not conn: return
    with conn.cursor() as cur: cur.execute(f"SELECT {column} FROM {table};"); targets = cur.fetchall()
    conn.close()
    if not targets: return await update.message.reply_text("هدفی یافت نشد.")
    
    sent, failed = 0, 0
    status_msg = await update.message.reply_text(f"⏳ در حال ارسال به {len(targets)} {target}...")
    for (target_id,) in targets:
        try:
            await context.bot.forward_message(chat_id=target_id, from_chat_id=update.message.reply_to_message.chat.id, message_id=update.message.reply_to_message.message_id)
            sent += 1
        except Exception as e:
            failed += 1
            logger.error(f"Broadcast failed for {target_id}: {e}")
    await status_msg.edit_text(f"🏁 ارسال تمام شد.\n\n✅ موفق: {sent}\n❌ ناموفق: {failed}")

async def fwdusers_command(update: Update, context: ContextTypes.DEFAULT_TYPE): await broadcast_command(update, context, "users")
async def fwdgroups_command(update: Update, context: ContextTypes.DEFAULT_TYPE): await broadcast_command(update, context, "groups")

async def leave_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده: /leave <group_id>")
    try:
        group_id = int(context.args[0])
        await context.bot.leave_chat(group_id)
        await update.message.reply_text(f"✅ با موفقیت از گروه `{group_id}` خارج شدم.", parse_mode=ParseMode.MARKDOWN)
    except Exception as e:
        await update.message.reply_text(f"خطا: {e}")

async def grouplist_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    conn = get_db_connection()
    if conn:
        with conn.cursor() as cur:
            cur.execute("SELECT group_id, title, member_count FROM groups;")
            groups = cur.fetchall()
        conn.close()
        if not groups: return await update.message.reply_text("ربات در هیچ گروهی عضو نیست.")
        message = "📜 **لیست گروه‌ها:**\n\n"
        for i, (group_id, title, member_count) in enumerate(groups, 1):
            message += f"{i}. **{title}**\n   - ID: `{group_id}`\n   - اعضا: {member_count}\n\n"
        await update.message.reply_text(message, parse_mode=ParseMode.MARKDOWN)

async def join_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده: /join <group_id>")
    try:
        group_id = int(context.args[0])
        link = await context.bot.create_chat_invite_link(group_id, member_limit=30)
        await update.message.reply_text(f"لینک ورود شما:\n{link.invite_link}")
    except Exception as e:
        await update.message.reply_text(f"خطا در ساخت لینک (شاید ربات ادمین نباشد): {e}")

async def ban_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده: /ban_user <user_id>")
    try:
        user_id = int(context.args[0])
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cur: cur.execute("INSERT INTO banned_users (user_id) VALUES (%s) ON CONFLICT DO NOTHING;", (user_id,))
            conn.commit(); conn.close()
            await update.message.reply_text(f"کاربر `{user_id}` با موفقیت مسدود شد.", parse_mode=ParseMode.MARKDOWN)
    except: await update.message.reply_text("آیدی نامعتبر است.")

async def unban_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده: /unban_user <user_id>")
    try:
        user_id = int(context.args[0])
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cur: cur.execute("DELETE FROM banned_users WHERE user_id = %s;", (user_id,))
            conn.commit(); conn.close()
            await update.message.reply_text(f"کاربر `{user_id}` با موفقیت از مسدودیت خارج شد.", parse_mode=ParseMode.MARKDOWN)
    except: await update.message.reply_text("آیدی نامعتبر است.")

async def ban_group_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Bans a group from using the bot."""
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده صحیح: /ban_group <group_id>")
    
    try:
        group_id = int(context.args[0])
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cur:
                cur.execute("INSERT INTO banned_groups (group_id) VALUES (%s) ON CONFLICT DO NOTHING;", (group_id,))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"گروه `{group_id}` با موفقیت مسدود شد.", parse_mode=ParseMode.MARKDOWN)
            
            # Bot leaves the group after banning it
            try:
                await context.bot.leave_chat(group_id)
            except Exception as e:
                logger.warning(f"Could not leave the banned group {group_id}: {e}")

    except (ValueError, IndexError):
        await update.message.reply_text("لطفا یک آیدی عددی معتبر برای گروه وارد کنید.")

async def unban_group_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Unbans a group."""
    if not await is_owner(update.effective_user.id): return
    if not context.args: return await update.message.reply_text("استفاده صحیح: /unban_group <group_id>")

    try:
        group_id = int(context.args[0])
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM banned_groups WHERE group_id = %s;", (group_id,))
            conn.commit()
            conn.close()
            await update.message.reply_text(f"گروه `{group_id}` با موفقیت از مسدودیت خارج شد.", parse_mode=ParseMode.MARKDOWN)
    except (ValueError, IndexError):
        await update.message.reply_text("لطفا یک آیدی عددی معتبر برای گروه وارد کنید.")

async def checkgps_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    اطلاعات گروه‌های ثبت‌شده در دیتابیس را به‌روزرسانی و یک گزارش کامل ارسال می‌کند.
    این دستور گروه‌های جدید را کشف نمی‌کند.
    """
    if not await is_owner(update.effective_user.id):
        return

    status_msg = await update.message.reply_text("⏳ لطفاً صبر کنید، در حال بررسی و به‌روزرسانی اطلاعات گروه‌ها...")
    
    conn = get_db_connection()
    if not conn:
        await status_msg.edit_text("❌ خطا در اتصال به دیتابیس.")
        return

    updated_count = 0
    error_count = 0
    final_report = []

    try:
        with conn.cursor() as cur:
            cur.execute("SELECT group_id FROM groups;")
            group_ids = cur.fetchall()
        
        if not group_ids:
            await status_msg.edit_text("ℹ️ هیچ گروهی در دیتابیس ثبت نشده است.")
            return

        await status_msg.edit_text(f"✅ تعداد {len(group_ids)} گروه در دیتابیس یافت شد. در حال به‌روزرسانی و تهیه گزارش...")

        for (group_id,) in group_ids:
            try:
                # گرفتن اطلاعات جدید از تلگرام
                chat_info = await context.bot.get_chat(group_id)
                member_count = await context.bot.get_chat_member_count(group_id)
                title = chat_info.title
                
                # به‌روزرسانی اطلاعات در دیتابیس
                with conn.cursor() as cur:
                    cur.execute("UPDATE groups SET title = %s, member_count = %s WHERE group_id = %s;", (title, member_count, group_id))
                conn.commit()
                updated_count += 1
                
                owner_mention = "نامشخص"
                try:
                    admins = await context.bot.get_chat_administrators(group_id)
                    for admin in admins:
                        if admin.status == 'creator':
                            owner_mention = f"[{admin.user.first_name}](tg://user?id={admin.user.id})"
                            break
                except Exception:
                    owner_mention = "خطا در دریافت"

                invite_link_text = "لینک دریافت نشد"
                try:
                    link = await context.bot.export_chat_invite_link(group_id)
                    invite_link_text = f"[ورود به گروه]({link})"
                except Exception:
                    pass

                report_text = (
                    f"📂 **{title}**\n"
                    f"🆔 `{group_id}`\n"
                    f"👥 {member_count} نفر | 👑 {owner_mention}\n"
                    f"🔗 {invite_link_text}"
                )
                final_report.append(report_text)

            except Exception as e:
                error_count += 1
                # اگر ربات از گروه اخراج شده باشد، آن را از دیتابیس حذف می‌کنیم
                if "chat not found" in str(e).lower():
                    with conn.cursor() as cur:
                        cur.execute("DELETE FROM groups WHERE group_id = %s;", (group_id,))
                    conn.commit()

            await asyncio.sleep(0.5) # تأخیر برای جلوگیری از محدودیت API

        # ارسال گزارش نهایی
        if final_report:
            full_message = "\n\n---\n\n".join(final_report)
            await status_msg.edit_text(
                f"📊 **گزارش نهایی گروه‌ها**\n\n"
                f"{full_message}\n\n"
                f"--- \n"
                f"🔄 {updated_count} گروه به‌روزرسانی شد.\n"
                f"⚠️ {error_count} گروه با خطا مواجه شد (احتمالاً ربات اخراج شده).",
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True
            )
        else:
            await status_msg.edit_text("گزارشی برای نمایش وجود ندارد. ممکن است ربات از تمام گروه‌ها اخراج شده باشد.")

    except Exception as e:
        await status_msg.edit_text(f"🚫 بروز خطای غیرمنتظره: {e}")
    finally:
        conn.close()

# -----------------
async def track_chats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    هنگام اضافه شدن ربات به گروه، اطلاعات را ثبت کرده و گزارش کاملی برای ادمین ارسال می‌کند.
    """
    # لاگ اولیه برای اطمینان از اجرای تابع
    logger.info("--- track_chats handler triggered ---")

    # --- بخش اصلاح شده برای سازگاری بیشتر با آپدیت‌های تلگرام ---
    # ابتدا سعی می‌کند از my_chat_member استفاده کند، اگر نبود از chat_member
    result = update.my_chat_member or update.chat_member
    
    if not result:
        logger.warning("Both my_chat_member and chat_member are empty in the update. Exiting.")
        return
    # --- پایان بخش اصلاح شده ---
    
    logger.info(f"Chat member update received. Old status: '{result.old_chat_member.status}', New status: '{result.new_chat_member.status}'")
    
    chat = result.chat
    user = result.from_user # کاربری که وضعیت را تغییر داده (ربات را اضافه کرده)
    
    # مطمئن می‌شویم که تغییر وضعیت مربوط به ربات ماست
    if result.new_chat_member.user.id != context.bot.id:
        return

    # --- وقتی ربات به گروه اضافه می‌شود ---
    if result.new_chat_member.status in ('member', 'administrator') and result.old_chat_member.status not in ('member', 'administrator'):
        logger.info(f"CONDITION MET: Bot was added to group '{chat.title}' ({chat.id})")
        
        conn = get_db_connection()
        if not conn:
            logger.error("Database connection FAILED inside track_chats.")
            return
        
        logger.info("Database connection successful.")
        
        try:
            # بخش بررسی محدودیت نصب (کد اصلی شما)
            with conn.cursor() as cur:
                cur.execute("SELECT COUNT(*) FROM groups;")
                group_count = cur.fetchone()[0]

            if group_count >= GROUP_INSTALL_LIMIT:
                await chat.send_message(f"⚠️ ظرفیت نصب این ربات تکمیل شده است! لطفاً با پشتیبانی (@{SUPPORT_USERNAME}) تماس بگیرید.")
                await context.bot.leave_chat(chat.id)
                for owner_id in OWNER_IDS:
                    await context.bot.send_message(owner_id, f"🔔 هشدار: سقف نصب ({GROUP_INSTALL_LIMIT}) تکمیل شد. ربات از گروه `{chat.title}` خارج شد.", parse_mode=ParseMode.MARKDOWN)
                return

            # ثبت اطلاعات در دیتابیس
            member_count = await chat.get_member_count()
            with conn.cursor() as cur:
                cur.execute("INSERT INTO groups (group_id, title, member_count) VALUES (%s, %s, %s) ON CONFLICT (group_id) DO UPDATE SET title = EXCLUDED.title, member_count = EXCLUDED.member_count;", (chat.id, chat.title, member_count))
            conn.commit()
            logger.info("SUCCESS: Group info was inserted/updated in the database.")

            await chat.send_message("شما به همراهان راینوسول پیوستید\n\n /start برای نصب کلی ربات کافیست این دستور را ارسال کنید\n\n /rsgame سپس با تک دستور ربات پنل بازی ها را باز کنید\n\nسپاس از همراهی شما...")

            # --- جمع‌آوری اطلاعات کامل برای گزارش ---
            
            # ۱. پیدا کردن مالک گروه
            owner_mention = "نامشخص"
            try:
                admins = await context.bot.get_chat_administrators(chat.id)
                for admin in admins:
                    if admin.status == 'creator':
                        # ساخت منشن قابل کلیک برای مالک
                        owner_mention = f"[{admin.user.first_name}](tg://user?id={admin.user.id})"
                        break
            except Exception as e:
                logger.warning(f"Could not get group owner for {chat.id}: {e}")

            # ۲. دریافت لینک ورود (در صورت داشتن دسترسی)
            invite_link_text = "لینک دریافت نشد (ربات ادمین نیست)"
            try:
                link = await context.bot.export_chat_invite_link(chat.id)
                invite_link_text = f"[ورود به گروه]({link})"
            except Exception as e:
                logger.warning(f"Could not get invite link for {chat.id}: {e}")
            
            # ۳. ساخت منشن قابل کلیک برای کاربری که ربات را اضافه کرده
            adder_mention = f"[{user.first_name}](tg://user?id={user.id})"

            # ۴. ساخت متن نهایی گزارش
            report = (
                f"➕ **ربات به گروه جدید اضافه شد:**\n\n"
                f"📝 **نام گروه:** {chat.title}\n"
                f"🆔 **آیدی عددی:** `{chat.id}`\n"
                f"👥 **تعداد اعضا:** {member_count} نفر\n\n"
                f"👑 **مالک گروه:** {owner_mention}\n"
                f"👤 **اضافه شده توسط:** {adder_mention}\n"
                f"🔗 **لینک ورود:** {invite_link_text}"
            )
            
            # ۵. ارسال گزارش به تمام ادمین‌های اصلی
            for owner_id in OWNER_IDS:
                try: 
                    await context.bot.send_message(owner_id, report, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
                except Exception as e:
                    logger.error(f"Failed to send report to owner {owner_id}: {e}")

        except Exception as e:
            logger.error(f"An unexpected error occurred in the main try block of track_chats: {e}")
        finally:
            conn.close()

    # --- وقتی ربات از گروه حذف می‌شود ---
    elif result.new_chat_member.status in ('left', 'kicked'):
        logger.info(f"CONDITION MET: Bot was removed from group '{chat.title}' ({chat.id})")
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cur:
                cur.execute("DELETE FROM groups WHERE group_id = %s;", (chat.id,))
            conn.commit()
            conn.close()
        
        report = f"❌ **ربات از گروه زیر اخراج شد:**\n\n🌐 نام: {chat.title}\n🆔: `{chat.id}`"
        for owner_id in OWNER_IDS:
            try: 
                await context.bot.send_message(owner_id, report, parse_mode=ParseMode.MARKDOWN)
            except Exception: 
                pass

async def stop_games_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    دستور لغو تمام بازی‌های فعال در یک گروه توسط ادمین.
    این دستور بازی‌های ناشناس (قارچ) را لغو نمی‌کند.
    """
    chat = update.effective_chat
    user = update.effective_user

    # ۱. این دستور فقط در گروه‌ها کار می‌کند
    if chat.type == 'private':
        await update.message.reply_text("این دستور فقط در گروه‌ها قابل استفاده است.")
        return

    # ۲. فقط ادمین‌ها می‌توانند از این دستور استفاده کنند
    if not await is_group_admin(user.id, chat.id, context):
        await update.message.reply_text("❌ شما اجازه استفاده از این دستور را ندارید. این دستور مخصوص مدیران است.")
        return
        
    chat_id = chat.id
    canceled_count = 0

    # ۳. لیست بازی‌هایی که باید لغو شوند
    # بازی قارچ (gharch) در این لیست نیست
    games_to_cancel = ['hangman', 'typing', 'guess_number']

    for game_key in games_to_cancel:
        # بررسی می‌کند آیا بازی از این نوع در این گروه فعال است یا خیر
        if chat_id in active_games.get(game_key, {}):
            # حذف تمام بازی‌های فعال آن نوع از گروه فعلی
            del active_games[game_key][chat_id]
            canceled_count += 1
            
    # ۴. ارسال پیام نتیجه به ادمین
    if canceled_count > 0:
        await update.message.reply_text(f"✅ با موفقیت {canceled_count} نوع بازی فعال لغو شد.")
    else:
        await update.message.reply_text("هیچ بازی فعالی برای لغو کردن در این گروه وجود نداشت.")

async def text_help_trigger(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """با دریافت کلمه 'راهنما'، پنل تعاملی راهنمای بازی‌ها را ارسال می‌کند."""
    user = update.effective_user
    text = f"راهنمای بازی‌ها برای {user.mention_html()}\n\n" \
           "لطفاً برای مشاهده توضیحات، روی نام هر بازی کلیک کنید:"

    # ساخت دکمه‌های پنل اصلی راهنما
    # user_id را به callback_data اضافه می‌کنیم تا پنل اختصاصی شود
    keyboard = [
        [
            InlineKeyboardButton("🏆 بازی‌های گروهی", callback_data=f"help_cat_board_{user.id}"),
            InlineKeyboardButton("👤 بازی‌های تک‌نفره", callback_data=f"help_cat_single_{user.id}")
        ],
        [
            InlineKeyboardButton("✍️ بازی‌های تایپی", callback_data=f"help_cat_typing_{user.id}"),
            InlineKeyboardButton("🤫 بازی‌های ناشناس", callback_data=f"help_cat_anon_{user.id}")
        ],
        [InlineKeyboardButton("✖️ بستن پنل", callback_data=f"help_close_{user.id}")]
    ]

    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)

async def help_panel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """کلیک روی دکمه‌های پنل راهنما را مدیریت می‌کند."""
    query = update.callback_query
    user = query.from_user
    data = query.data.split('_')
    
    # --- بخش امنیتی (بدون تغییر) ---
    try:
        target_user_id = int(data[-1])
        if user.id != target_user_id:
            await query.answer("این پنل راهنما برای شما نیست!", show_alert=True)
            return
    except (ValueError, IndexError):
        await query.answer("خطا: دکمه نامعتبر است.", show_alert=True)
        return
    # --- پایان بخش امنیتی ---

    await query.answer()
    action = data[1]

    if action == "close":
        try:
            await query.delete_message()
        except Exception:
            await query.edit_message_text("پنل راهنما بسته شد.")
        return
        
    elif action == "main":
        # ... (این بخش بدون تغییر باقی می‌ماند)
        text = f"راهنمای بازی‌ها برای {user.mention_html()}\n\n" \
               "لطفاً برای مشاهده توضیحات، روی نام هر بازی کلیک کنید:"
        keyboard = [
            [
                InlineKeyboardButton("🏆 بازی‌های گروهی", callback_data=f"help_cat_board_{user.id}"),
                InlineKeyboardButton("👤 بازی‌های تک‌نفره", callback_data=f"help_cat_single_{user.id}")
            ],
            [
                InlineKeyboardButton("✍️ بازی‌های تایپی", callback_data=f"help_cat_typing_{user.id}"),
                InlineKeyboardButton("🤫 بازی‌های ناشناس", callback_data=f"help_cat_anon_{user.id}")
            ],
            [InlineKeyboardButton("✖️ بستن پنل", callback_data=f"help_close_{user.id}")]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)

    elif action == "game":
        # ========== این بخش اصلاح شده است ==========
        # کلید بازی ممکن است چند بخشی باشد (مثل hads_kalame)
        # پس تمام بخش‌ها بین 'game' و آیدی عددی را به هم می‌چسبانیم
        game_key = "_".join(data[2:-1])
        # ==========================================
        
        game_name = " ".join(word.capitalize() for word in game_key.replace('_', ' ').split())
        description = GAME_DESCRIPTIONS.get(game_key, "توضیحات این بازی یافت نشد.")
        keyboard = [[InlineKeyboardButton("🔙 بازگشت به منوی اصلی", callback_data=f"help_main_{user.id}")]]
        await query.edit_message_text(f"📖 **توضیحات بازی {game_name}**:\n\n{description}", 
                                      reply_markup=InlineKeyboardMarkup(keyboard), 
                                      parse_mode=ParseMode.MARKDOWN)

    elif action == "cat":
        # ... (این بخش بدون تغییر و کامل است) ...
        category = data[2]
        keyboard = []
        text = "لطفا بازی مورد نظر را انتخاب کنید:"

        if category == "board":
            text = "🏆 **راهنمای بازی‌های گروهی:**"
            keyboard.extend([
                [InlineKeyboardButton("حکم", callback_data=f"help_game_hokm_{user.id}")],
                [InlineKeyboardButton("دوز (۲ نفره)", callback_data=f"help_game_dooz_{user.id}")],
                [InlineKeyboardButton("دوز (۴ نفره)", callback_data=f"help_game_doz4p_{user.id}")],
                [InlineKeyboardButton("چهار در یک ردیف", callback_data=f"help_game_connect4_{user.id}")],
                [InlineKeyboardButton("سنگ کاغذ قیچی", callback_data=f"help_game_rps_{user.id}")],
                [InlineKeyboardButton("بازی حافظه", callback_data=f"help_game_memory_{user.id}")],
            ])
        
        elif category == "single":
            text = "👤 **راهنمای بازی‌های تک‌نفره:**"
            keyboard.extend([
                [InlineKeyboardButton("2048", callback_data=f"help_game_2048_{user.id}")],
                [InlineKeyboardButton("پازل کشویی", callback_data=f"help_game_spuzzle_{user.id}")],
                [InlineKeyboardButton("بازی جفت‌ها", callback_data=f"help_game_samegame_{user.id}")],
            ])

        elif category == "typing":
            text = "✍️ **راهنمای بازی‌های تایپی و سرعتی:**"
            keyboard.extend([
                [InlineKeyboardButton("حدس کلمه", callback_data=f"help_game_hads_kalame_{user.id}")],
                [InlineKeyboardButton("تایپ سرعتی", callback_data=f"help_game_type_speed_{user.id}")],
                [InlineKeyboardButton("حدس عدد", callback_data=f"help_game_hads_addad_{user.id}")],
            ])

        elif category == "anon":
            text = "🤫 **راهنمای بازی‌های ناشناس و ادمین:**"
            keyboard.extend([
                [InlineKeyboardButton("اعتراف", callback_data=f"help_game_eteraf_{user.id}")],
                [InlineKeyboardButton("قارچ", callback_data=f"help_game_gharch_{user.id}")],
                [InlineKeyboardButton("گردونه شانس", callback_data=f"help_game_gardone_{user.id}")],
            ])
        
        keyboard.append([InlineKeyboardButton("🔙 بازگشت به منوی اصلی", callback_data=f"help_main_{user.id}")])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)

async def ping_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    سرعت پاسخ‌دهی (latency) ربات را محاسبه کرده و فقط برای مالک ربات ارسال می‌کند.
    """
    # ۱. زمان شروع را قبل از ارسال پیام ثبت می‌کنیم
    start_time = time.time()
    
    # ۲. یک پیام اولیه ارسال می‌کنیم تا بتوانیم آن را ویرایش کنیم
    message = await update.message.reply_text("...")
    
    # ۳. زمان پایان را پس از ارسال پیام ثبت می‌کنیم
    end_time = time.time()
    
    # ۴. اختلاف زمان را محاسبه و به میلی‌ثانیه تبدیل می‌کنیم
    latency_s = end_time - start_time
    
    # ۵. پیام اولیه را با نتیجه نهایی ویرایش می‌کنیم
    await message.edit_text(f"راینو گیم آنلاین است!\n\n⚡️پاسخگویی: {latency_s:.4f} ثانیه")

# =================================================================
def main() -> None:
    """Start the bot."""
    setup_database()
    BOT_TOKEN = os.environ.get("BOT_TOKEN")
    if not BOT_TOKEN:
        logger.critical("BOT_TOKEN environment variable not set.")
        return

    application = Application.builder().token(BOT_TOKEN).build()
    
    # --- Conversation Handlers ---
    gharch_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(gharch_start_callback, pattern=r'^gharch_start_')],
        states={
            ASKING_GOD_USERNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_god_username)],
            CONFIRMING_GOD: [CallbackQueryHandler(confirm_god, pattern=r'^gharch_confirm_god_')],
        },
        fallbacks=[CommandHandler('cancel', cancel_gharch_conv)],
        per_user=False, per_chat=True,
    )
    
    guess_number_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(hads_addad_start_callback, pattern=r'^hads_addad_start_')],
        states={
            SELECTING_RANGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_range)],
            GUESSING: [MessageHandler(filters.Regex(r'^[\d۰-۹]+$'), handle_guess_conversation)],
        },
        fallbacks=[CommandHandler('cancel', cancel_game_conversation)],
        per_user=False, per_chat=True
    )

    eteraf_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(eteraf_start_callback, pattern=r'^eteraf_start_custom_')],
        states={
            ENTERING_ETERAF_TEXT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_eteraf_text)]
        },
        fallbacks=[CommandHandler('cancel', cancel_game_conversation)],
        per_user=True, per_chat=False
    )
    
    application.add_handler(gharch_conv)
    application.add_handler(guess_number_conv)
    application.add_handler(eteraf_conv)

    # --- Command Handlers (بدون تغییر) ---
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("rsgame", rsgame_command))
    application.add_handler(CommandHandler("stop", stop_games_command))
    
    # دستورات مالک ربات (بدون تغییر)
    application.add_handler(CommandHandler("setstart", set_start_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("stats", stats_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("fwdusers", fwdusers_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("fwdgroups", fwdgroups_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("leave", leave_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("grouplist", grouplist_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("join", join_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("ban_user", ban_user_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("unban_user", unban_user_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("ban_group", ban_group_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("unban_group", unban_group_command, filters=filters.User(OWNER_IDS)))
    application.add_handler(CommandHandler("checkgps", checkgps_command, filters=filters.User(OWNER_IDS)))

    # ========================== بخش اصلی تغییرات اینجاست ==========================
    # --- CallbackQueryHandlers ---
    # ترتیب بسیار مهم است: از هندلرهای اختصاصی‌تر به عمومی‌تر می‌رویم.

    # ۱. هندلرهای عمومی رابط کاربری (که بخشی از یک بازی خاص نیستند)
    application.add_handler(CallbackQueryHandler(rsgame_check_join_callback, pattern=r'^rsgame_check_join$'))
    application.add_handler(CallbackQueryHandler(rsgame_close_callback, pattern=r'^rsgame_close_'))
    application.add_handler(CallbackQueryHandler(rsgame_pv_callback, pattern=r'^rsgame_cat_main_pv$'))
    
    # ۲. تمام هندلرهای مربوط به بازی‌ها (شروع و حرکات داخلی)
    # این‌ها باید قبل از هندلر عمومی منوها بیایند
    application.add_handler(CallbackQueryHandler(hads_kalame_start_callback, pattern=r'^hads_kalame_start_'))
    application.add_handler(CallbackQueryHandler(type_start_callback, pattern=r'^type_start_'))
    application.add_handler(CallbackQueryHandler(eteraf_start_callback, pattern=r'^eteraf_start_default_'))
    
    application.add_handler(CallbackQueryHandler(hokm_callback, pattern=r'^hokm_'))
    application.add_handler(CallbackQueryHandler(dooz_callback, pattern=r'^dooz_'))
    application.add_handler(CallbackQueryHandler(connect4_callback, pattern=r'^connect4_'))
    application.add_handler(CallbackQueryHandler(rps_callback, pattern=r'^rps_'))
    application.add_handler(CallbackQueryHandler(memory_callback, pattern=r'^memory_'))
    application.add_handler(CallbackQueryHandler(game_2048_callback, pattern=r'^2048_'))
    application.add_handler(CallbackQueryHandler(samegame_callback, pattern=r'^samegame_'))
    application.add_handler(CallbackQueryHandler(spuzzle_callback, pattern=r'^spuzzle_'))
    application.add_handler(CallbackQueryHandler(doz4p_callback, pattern=r'^doz4p_'))
    application.add_handler(CallbackQueryHandler(gardone_callback, pattern=r'^gardone_'))
    # ۳. هندلر عمومی ناوبری در منوها (باید در آخر این بخش باشد)
    application.add_handler(CallbackQueryHandler(help_panel_callback, pattern=r'^help_'))
    # این هندلر فقط زمانی اجرا می‌شود که هیچ‌کدام از الگوهای اختصاصی‌تر بالا مطابقت نداشته باشند
    application.add_handler(CallbackQueryHandler(rsgame_callback_handler, pattern=r'^rsgame_cat_'))
    
    # ========================== پایان بخش تغییرات ==========================

    # --- Message Handlers (بدون تغییر) ---
    application.add_handler(MessageHandler(filters.Regex(r'^راهنما$'), text_help_trigger))
    application.add_handler(MessageHandler(filters.Regex(r'^پینگ$') & filters.User(OWNER_IDS), ping_command))
    application.add_handler(MessageHandler(filters.Regex(r'^[آ-ی]$') & filters.ChatType.GROUPS, handle_letter_guess))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, handle_anonymous_message))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.GROUPS, handle_typing_attempt))
    
    # --- سایر Handler ها (بدون تغییر) ---
    application.add_handler(ChatMemberHandler(track_chats, ChatMemberHandler.MY_CHAT_MEMBER))
    
    logger.info("Bot is starting with the new refactored logic...")
    application.run_polling()

if __name__ == "__main__":
    main()
